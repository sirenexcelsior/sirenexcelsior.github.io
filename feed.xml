<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://sirenexcelsior.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sirenexcelsior.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-08T14:57:21+00:00</updated><id>https://sirenexcelsior.github.io/feed.xml</id><title type="html">blank</title><subtitle>A SiREN&apos;s HomePage. </subtitle><entry><title type="html">Программа государственного экзамена по направлениям магистратуры</title><link href="https://sirenexcelsior.github.io/blog/2024/gosa/" rel="alternate" type="text/html" title="Программа государственного экзамена по направлениям магистратуры"/><published>2024-05-01T17:39:00+00:00</published><updated>2024-05-01T17:39:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/gosa</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/gosa/"><![CDATA[<p>Redirecting to pdf.</p>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><summary type="html"><![CDATA[Redirecting to pdf.]]></summary></entry><entry><title type="html">吉米多维奇习题集 - 不定积分</title><link href="https://sirenexcelsior.github.io/blog/2024/math-analysis-Demidovich-integral/" rel="alternate" type="text/html" title="吉米多维奇习题集 - 不定积分"/><published>2024-04-11T00:00:00+00:00</published><updated>2024-04-11T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/math-analysis-Demidovich-integral</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/math-analysis-Demidovich-integral/"><![CDATA[<h2 id="一些有用的书籍">一些有用的书籍</h2> <ul> <li><a href="https://sirenexcelsior.github.io/assets/pdf/math_analysis/Лекции_по_математическому_анализу.pdf">Лекции по математическому анализу</a></li> <li><a href="https://sirenexcelsior.github.io/assets/pdf/math_analysis/Сборник_задач_и_упражнений_по_математическому_анализу.pdf">Сборник задач и упражнений по математическому анализу</a></li> <li><a href="https://sirenexcelsior.github.io/assets/pdf/math_analysis/俄罗斯数学教材选译_10_数学分析习题集根据2010年俄文版翻译_俄Б_П_吉米多维奇_高等教育出版社_2010.pdf">吉米多维奇数学分析习题集</a></li> </ul> <h2 id="不定积分的基本性质">不定积分的基本性质</h2> \[d[\int f(x)dx]=f(x)dx, \int d\Phi (x)+C\] \[\int Af(x)dx=A\int f(x)dx,A=const,A\ne 0\] \[\int[f(x)+g(x)]dx=\int f(x)dx+\int g(x)dx\] <h2 id="最简积分表">最简积分表</h2> \[\begin{aligned}&amp;\mathrm{I.}\int x^{n}\mathrm{d}x=\frac{x^{n+1}}{n+1}+C(n\neq-1).\quad\mathrm{II.}\int\frac{\mathrm{d}x}{x}=\ln|x|+C(x\neq0).\\&amp;\mathrm{III.}\int\frac{\mathrm{d}x}{1+x^{2}}=\begin{cases}\arctan x+C,\\-\arctan x+C.\end{cases}\quad\mathrm{IV.}\int\frac{\mathrm{d}x}{1-x^{2}}=\frac{1}{2}\ln\left|\frac{1+x}{1-x}\right|+C.\\&amp;\mathrm{V.}\int\frac{\mathrm{d}x}{\sqrt{1-x^{2}}}=\begin{cases}\arctan x+C,\\-\arccos x+C.\end{cases}\quad\mathrm{VI.}\int\frac{\mathrm{d}x}{\sqrt{x^{2}\pm1}}=\ln\left|x+\sqrt{x^{2}\pm1}\right|+C.\\&amp;\mathrm{VII.}\int a^{x}\mathrm{d}x=\frac{a^{x}}{\ln a}+C(a&gt;0,a\neq1);\quad\int\mathrm{e}^{x}\mathrm{d}x=\mathrm{e}^{x}+C.\\&amp;\mathrm{VII.}\int\sin x\mathrm{d}x=-\cos x+C.\quad\mathrm{IX.}\int\cos x\mathrm{d}x=\sin x+C.\\&amp;\mathrm{X.}\int{\frac{\mathrm{d}x}{\sin^{2}x}}=-\cot x+C.\quad\mathrm{XI.}\int{\frac{\mathrm{d}x}{\cos^{2}x}}=\tan x+C.\\&amp;\mathrm{XII.}\int\sinh x\mathrm{d}x=\cosh x+C.\quad\mathrm{XIII.}\int\cosh x\mathrm{d}x=\sinh x+C.\\&amp;\mathrm{XIV.}\int{\frac{\mathrm{d}x}{\sinh^{2}x}}=-\coth x+C.\quad\mathrm{XI.}\int{\frac{\mathrm{d}x}{\cosh^{2}x}}=\tanh x+C.\end{aligned}\] <h2 id="利用最简积分表求积分">利用最简积分表求积分</h2> <h3 id="1628">1628</h3> <p>\(\int (3-x^2)^3dx\).</p> <p>\(\int (3-x^2)^3dx=\int (27-27x^2+9x^4-x^6)dx\). \(=27x-9x^3+\frac{9}{5}x^5-\frac{1}{7}x^7+C\).</p> <h3 id="1636">1636</h3> <p>\(\int (1-\frac{1}{x^2})\sqrt[]{x\sqrt[]{x} }dx\).</p> <p>\(\int (1-\frac{1}{x^2})\sqrt[]{x\sqrt[]{x} }dx =\int (x^{\frac{3}{4}}-x^{-\frac{4}{5}})dx\).</p> <p>\(=\frac{4}{7}x^{\frac{7}{4}}+4x^{-\frac{1}{4}}+C=\frac{4(x^2+7)}{7\sqrt[4]{x} }+C\).</p> <blockquote> <p>可以分解成形如\(\int x^{a_1}+\cdots+x^{a_n}dx\)的不定积分。</p> </blockquote>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><category term="Analysis"/><summary type="html"><![CDATA[一些有用的书籍]]></summary></entry><entry><title type="html">Доп. главы по Мат. Анализу</title><link href="https://sirenexcelsior.github.io/blog/2024/math-analysis/" rel="alternate" type="text/html" title="Доп. главы по Мат. Анализу"/><published>2024-04-11T00:00:00+00:00</published><updated>2024-04-11T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/math-analysis</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/math-analysis/"><![CDATA[<h2 id="несколько-полезных-книг">Несколько полезных книг</h2> <ul> <li><a href="https://sirenexcelsior.github.io/assets/pdf/math_analysis/Лекции_по_математическому_анализу.pdf">Лекции по математическому анализу</a></li> <li><a href="https://sirenexcelsior.github.io/assets/pdf/math_analysis/Сборник_задач_и_упражнений_по_математическому_анализу.pdf">Сборник задач и упражнений по математическому анализу</a></li> <li><a href="https://sirenexcelsior.github.io/assets/pdf/math_analysis/俄罗斯数学教材选译_10_数学分析习题集根据2010年俄文版翻译_俄Б_П_吉米多维奇_高等教育出版社_2010.pdf">吉米多维奇数学分析习题集</a></li> <li><a href="https://sirenexcelsior.github.io/assets/pdf/math_analysis/Математический_анализ_в_задачах_и_упражнениях_том_1.pdf">Математический анализ в задачах и упражнениях том 1</a></li> <li><a href="https://sirenexcelsior.github.io/assets/pdf/math_analysis/Математический_анализ_в_задачах_и_упражнениях_том_3.pdf">Математический анализ в задачах и упражнениях том 3</a></li> </ul> <h2 id="действительные-числа">Действительные числа</h2> <p><strong>Опр.</strong> Непустое множество называется множеством действительных (вещественных) чисел, а его элементы — действительными (вещественными) числами, если на определены операции сложения и умножения и отношение порядка, удовлетворяющие следующим аксиома.</p> <ol> <li>Аксиомы сложения \((a,b\to a+b)\): <ol> <li>Коммутативность: \(a+b=b+a, \forall a,b\in \mathbb{R}\);</li> <li>Ассоциативность: \(a+(b+c)=(a+b)+c\);</li> <li>\(\exists 0\in \mathbb{R}:a+0=a,\forall a\in \mathbb{R}\);</li> <li>\(\forall a\in \mathbb{R},\exists (-a)\in \mathbb{R}:a+(-a)=0,(-a)\) называется <strong><em>противополжным числом</em></strong> для \(a\).</li> </ol> </li> <li> <p>Аксиомы умножения \((a,b\to ab)\):</p> <ol> <li>Коммутативность: \(ab=ba, \forall a,b\in \mathbb{R}\);</li> <li>Ассоциативность: \(a(bc)=(ab)c\);</li> <li>\(\exists 1\in \mathbb{R}, 1\ne 0:a1=a,\forall a\in \mathbb{R}\);</li> <li>\(\forall a\in \mathbb{R},a\ne 0,\exists \frac{1}{a}\in \mathbb{R}:a\frac{1}{a}=1,\frac{1}{a}\) называется <strong><em>обратным числом</em></strong> для \(a\).</li> </ol> </li> <li> <p>Связь сложения и умножения:</p> <ol> <li>\((a+b)c=ac+bc,\forall a,b,c\in \mathbb{R}\) - дистрибутивность умножения относительно сложения.</li> </ol> </li> <li> <p>Аксиомы порядка (для любых \(a,b\in \mathbb{R}\) установлено отношение \(a\le b\) или \(a\ge b\)):</p> <ol> <li>\(a\le b,b\le a \Rightarrow a=b,\forall a,b\in \mathbb{R}\);</li> <li>\(a\le b,b\le c \Rightarrow a\le c,\forall a,b,c\in \mathbb{R}\).</li> </ol> </li> <li> <p>Связь сложения и порядка:</p> <ol> <li>\(a\le b\Rightarrow a+c\le b+c,\forall a,b,c\in \mathbb{R}\).</li> </ol> </li> <li> <p>Связь умножения и порядка:</p> <ol> <li>\(0\le a, 0\le b\Rightarrow 0\le ab,\forall a,b,c\in \mathbb{R}\).</li> </ol> </li> <li> <p>Аксиома непрерывности (вариант принципа Дедекинда):</p> <ol> <li> <p>Пусть \(A,B\) - непустые подмножества \(\mathbb{R}\), такие, что</p> \[a\le b, \forall a\in A, \forall b\in B\] <p>Тогда существует \(c\in \mathbb{R}\):</p> \[a\le c\le b, \forall a\in A, \forall b\in B\] </li> </ol> </li> </ol> <blockquote> <p>实数集合就是满足以上性质的非空集合，其中的元素叫做实数。</p> <ol> <li>对于加法：满足交换律，结合率，有零元和逆元，</li> <li>对于乘法：满足交换律，结合率，有单位元和逆元，</li> <li>乘法对加法满足分配率，</li> <li>顺序公理以及连续性公理。</li> </ol> </blockquote> <h2 id="теорема-о-точной-грани">Теорема о точной грани</h2> <p><strong>Теорема.</strong> (о существовании верхней (нижней) грани). Всякое непустое ограниченное сверху (снизу) числовое множество имеет верхнюю (нижнюю) грань.</p> <blockquote> <p>该定理可以表述为：所有具备上界的非空数集都有上确界（下界和下确界同理）。</p> </blockquote> <p><strong>Доказательство.</strong> проведём лишь для верхней грани. Пусть \(A\) — непустое ограниченное сверху множество. Рассмотрим непустое множество \(B\), элементами которого являются все числа \(b\), ограничивающие множество \(A\) сверху.</p> <p>Тогда</p> \[a\le b, \forall a\in A, \forall b\in B\] <p>В силу аксиомы непрерывности для некоторого \(c\in \mathbb{R}\):</p> \[a\le c\le b, \forall a\in A, \forall b\in B\] <p>Покажем, что \(\exists \sup A=c\). Первое условие из определения верхней грани выполняется для с в силу левого из неравенств.</p> <p>Убедимся, что выполняется и второе. Пусть \(c'&lt;c\). Тогда \(c'\in B\), так как для каждого элемента из \(В\) выполняется правое из неравенств. Следовательно, \(c'\) не ограничивает множество \(А\) сверху, т. е.</p> \[\exists x_{c'} \in A:x_{c'}&gt;c'\] <p>так что второе условие также выполняется.</p> <p>Следовательно, \(c=\sup A\) и теорема доказана.</p> <blockquote> <p>该证明过程核心在于“实数系的完备公理”，<strong>戴德金完备性</strong>（вариант принципа Дедекинда）的表述是：如果实数集合被任意两个非空集合所分割，其中一个集合中的所有元素总是小于另一个集合中的任何元素，那么存在一个实数，它要么是第一个集合的最大元素，要么是第二个集合的最小元素。</p> </blockquote> <h2 id="счетность-множества-рациональных-чисел">Счетность множества рациональных чисел</h2> <p><strong>Опр.</strong> Множество называется счётным,еслионо эквивалентно множеству натуральных чисел, иначе говоря, если его можно занумеровать всеми натуральными числами.</p> <blockquote> <p>如果一个集合可以通过自然数来编号，那么这个集合就是可数的。</p> </blockquote> <p><strong>Теорема.</strong> Множество рациональных чисел счётно.</p> <p><strong>Доказательство.</strong> Составим таблицу чисел (открытую снизу и справа), содержащую все рациональные числа:</p> <div class="row mt-3"> <div class="col-12 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/202404/math_analysis_1-480.webp 480w,/assets/img/202404/math_analysis_1-800.webp 800w,/assets/img/202404/math_analysis_1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/202404/math_analysis_1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Будем двигаться по клеткам этой таблицы из левого верхнего угла по следующему пути:</p> <div class="row mt-3 justify-content-center"> <div class="col-3 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/202404/math_analysis_2-480.webp 480w,/assets/img/202404/math_analysis_2-800.webp 800w,/assets/img/202404/math_analysis_2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/202404/math_analysis_2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>нумеруя встречающиеся в клетках рациональные числа и пропуская при этом те из них, которые ранее уже встречались.</p> <p>Очевидно, таким способом мы занумеруем все рациональные числа всеми натуральными, что и требовалось доказать.</p> <blockquote> <p>由之前可数的定义可以自然而然的将每一个有理数通过这个方法进行的编号，以此来证明有理数是可数的。</p> </blockquote> <h2 id="несчетность-множества-действительных-чисел">Несчетность множества действительных чисел</h2> <p><strong>Теорема.</strong> (Кантора). Множество всех точек отрезка \([0,1]\) несчётно.</p> <p><strong>Доказательство.</strong> Допустим противное.</p> <p>Тогда все точки отрезка \([0,1]\) можно занумеровать: \(x_1,x_2,x_3,\cdots\).</p> <blockquote> <p>首先，利用反证法：假设\([0,1]\)上的点是可数的，即可以使用\(x_1,x_2,x_3,\cdots\)进行标号。</p> </blockquote> <p>Поделим отрезок \([0,1]\) на три равных отрезка и обозначим через \([a_1,b_1]\) один из них, свободный от точки \(х_1\).</p> <p>Поделим \([a_1,b_1]\) на три равных отрезка и обозначим через \([a_2,b_2]\) один из них, свободный от точки \(х_2\).</p> <p>Продолжая процесс, получим систему вложенных отрезков \(\{[a_n,b_n]\}^{\infty }_{n=1}\). По теореме о вложенных отрезках существует точка \(с\), принадлежащая всем отрезкам системы. Эта точка \(с\) не совпадает ни \(с\) одной из занумерованных точек \(х_1,x_2,x_3\cdots\), так как любая из них \(x_j\) не содержится в отрезке \([a_j,b_j]\), в то время как \(с\) содержится в этом отрезке.</p> <blockquote> <p>然后我们将当前区间三等分，一定能找到一个不包含点\(x_1\)的区间，</p> <p>在这个区间里，我们再次等分，一定也能找到一个不包含点\(x_2\)的区间，</p> <p>继续下去，我们就能在每次划分区间时，依次避开之前所有的标号点\(x_1,x_2,x_3,\cdots\)，</p> <p>这也就意味着我们可以设置这么一个区间套，避开来所有的标号点。</p> </blockquote> <p>Итак, при допущении, что все точки отрезка \([0,1]\) занумерованы, мы пришли к противоречию, найдя точку \(c\in [0,1]\), отличную от каждой из занумерованных. Это противоречие показывает, что наше допущение неверно. Теорема доказана.</p> <blockquote> <p>根据区间套定理，这个区间套到极限时，一定是存在唯一一个点\(c\)在这个区间套里的，恰巧它又避开了之前所有的标号点，产生了矛盾，得证。</p> </blockquote>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><category term="Analysis"/><summary type="html"><![CDATA[Дополнительные главы поматематическому анализу]]></summary></entry><entry><title type="html">DeltaConv：用于点云几何深度学习的各向异性算子</title><link href="https://sirenexcelsior.github.io/blog/2024/deltaconv/" rel="alternate" type="text/html" title="DeltaConv：用于点云几何深度学习的各向异性算子"/><published>2024-04-03T00:00:00+00:00</published><updated>2024-04-03T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/deltaconv</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/deltaconv/"><![CDATA[<blockquote> <p>DeltaConv： 用于点云几何深度学习的各向异性算子</p> <p>RUBEN WIERSMA, AHMAD NASIKUN等</p> <p>GitHub：<a href="https://github.com/rubenwiersma/deltaconv">deltaconv</a></p> <p>翻译自：<a class="citation" href="#wiersma2022deltaconv">(Wiersma et al., 2022)</a></p> </blockquote> <h2 id="摘要">摘要</h2> <p>受图像深度学习的成功和三维数据可用性增加的推动，从三维点云数据中学习的势头迅猛发展。在本文中，我们的目标是构建各向异性卷积层，直接作用于由点云导出的曲面。由于缺乏用于表面切向方向的全局坐标系，这具有挑战性。我们介绍的 DeltaConv 是一种卷积层，它结合了向量微积分中的几何算子，能够在点云上构建各向异性滤波器。由于这些算子是在标量场和矢量场上定义的，因此我们将网络分为标量流和矢量流，并通过算子将它们连接起来。矢量流使网络能够明确表示、评估和处理方向信息。我们的卷积既稳健又易于实现，在多个基准测试中与最先进的方法不相上下，甚至更胜一筹，同时还能加快训练和推理速度。</p> <h2 id="引言">引言</h2> <p>卷积神经网络（CNN）在图像上的成功以及点云数据可用性的不断提高，促使人们将 CNN 从图像推广到三维点云[Bronstein 等人，2017 年；Guo 等人，2020 年；Liu 等人，2019d]。实现这一目标的方法之一是设计直接在曲面上运行的卷积。这种内在卷积将内核空间缩小为切线空间，而切线空间在曲面上是二维的。与外在卷积相比，内在卷积的效率更高，核的搜索空间也更小，它们自然会忽略空的空间，而且对刚性和非刚性变形都很稳健[Boscaini 等人，2016]。点云本征卷积的例子有 GCN [Kipfand Welling 2017]、PointNet++ [Qi 等人 2017b]、EdgeConv [Wang 等人 2019] 和 DiffusionNet [Sharp 等人 2021]。</p> <p>我们的重点是构建各向异性或与方向相关的本征卷积。由于非线性流形缺乏全局坐标系这一基本挑战，这一点很难做到。为了说明这个问题，请看图像上的 CNN（图 1，左）。由于图像具有全局一致的向上方向，因此网络可以建立各向异性过滤器，以相同的方式激活整个图像。例如，一个滤波器可以检测垂直边缘，另一个可以检测水平边缘。无论图像中的边缘在哪里，滤波器的响应都是一致的。在后续层中，可以将这些滤波器的输出进行组合，例如，找到一个角落。由于我们在曲面上没有全局坐标系（图 1，右），因此无法像在图像上那样建立和使用各向异性滤波器。这就限制了目前对点云的固有卷积。例如，GCNs 滤波器是各向同性的。PointNet++ 使用最大聚合并添加相对点位置，但仍对每个相邻点应用相同的权重矩阵。</p> <div class="row mt-3"> <div class="col-12 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/202404/deltaconv_1-480.webp 480w,/assets/img/202404/deltaconv_1-800.webp 800w,/assets/img/202404/deltaconv_1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/202404/deltaconv_1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 1. 图像有一个全局坐标系（左图）。点云则没有（右图），这使得各向异性卷积的设计变得复杂。 </div> <p>我们介绍了一种为几何 CNN 构建各向异性卷积层的新方法。我们的卷积是用几何算子而不是核来描述的。基于算子的视角是 GCN 所熟悉的，GCN 使用图上的拉普拉斯。虽然 Laplacian 非常适合曲面的内在学习，但它是各向同性的。创建各向异性算子的经典方法是将拉普拉斯函数写成梯度发散，并对中间向量场进行线性或非线性运算 [Weickert 1998]。在此基础上，我们从基本几何算子中构建了可学习的各向异性算子：<strong>梯度、共梯度、发散、卷积、拉普拉斯和霍奇拉普拉斯</strong>。这些算子定义在标量场和切线向量场的空间上。因此，我们的网络分为两个流：一个流包含标量，另一个包含切向矢量。算子沿着这两个流进行映射，并在这两个流之间进行映射。向量流编码沿表面的特征激活和方向，使网络能够在后续层中测试和关联方向。根据任务的不同，网络会输出标量或向量。由这些算子构建的网络具有与坐标无关的特性：虽然需要选择点云切线空间的基点，但无论选择什么基点，网络学习到的权重都是相同的。因此，尽管表面上缺乏全局坐标系，我们也可以实现与方向相关的卷积，而无需专门构建切空间基。我们将我们的卷积命名为 DeltaConv。</p> <div class="row mt-3"> <div class="col-12 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/202404/deltaconv_2-480.webp 480w,/assets/img/202404/deltaconv_2-800.webp 800w,/assets/img/202404/deltaconv_2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/202404/deltaconv_2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 2. 用 20 个各向异性扩散步骤创建的目标图像过度拟合了具有不同卷积的 ResNet。DeltaConv 可以很好地再现滤波器，而其他卷积则很难。(美国国家航空航天局提供） </div> <p>要了解 DeltaConv 的优势，可以考虑 Perona 和 Malik [1990] 提出的各向异性图像滤波器。Perona-Malik 滤波器整合了各向异性扩散方程，其中各向异性算子结合了梯度、非线性和发散。DeltaConv 可以访问构建这种各向异性算子所需的构件，并执行扩散方程的显式积分步骤。图 2 举例说明了这一点。我们训练了一个简单的 ResNet [He 等人，2016 年]，以匹配样本图像上二十个各向异性扩散步骤的结果。DeltaConv 可以很好地再现滤波器，而其他固有卷积和常规图像卷积则无法捕捉到这种效果，反而会产生过于平滑的信号或伪影。我们的方法还有以下优点：通过在整个网络中保持矢量特征流，我们的卷积可以将表面不同点之间的方向信息联系起来。正如我们在实验中展示的那样，由于各向异性，卷积的表现力得到了增强，因此与各向同性卷积以及最先进的方法相比，我们的准确性也得到了提高。此外，<u>每个算子都以稀疏矩阵的形式实现，算子的组合按点计算，简单高效。</u></p> <p>在我们的实验中，我们证明了仅有几个 DeltaConv 块的简单架构可以与使用更复杂架构的先进结果相媲美，在某些情况下甚至超过了先进结果。我们在 ModelNet40 上取得了 93.8% 的准确率，在 ScanObjectNN 最难的变体上取得了 84.7% 的准确率，在 ShapeNet 上取得了 86.9 mIoU 的准确率，在非刚性变形形状数据集 SHREC11 上取得了 99.6% 的准确率。我们的消融研究表明，与基于边缘的特征相比，添加矢量流可将 ModelNet40 的误差降低 25%（从 90.4% 降至 92.8%），将 ShapeNet 的误差降低 21%（从 81.1 mIoU 降至 85.1 mIoU），而使用每点方向特征可将推理速度提高 1.5 - 2 倍，将后向传递速度提高 2.5 - 30 倍。总结一下我们的主要贡献：</p> <ul> <li>我们为几何 CNN 引入了一种新的卷积层结构，它支持各向异性滤波器的构建。这是通过让网络学习卷积作为几何微分算子和随点非线性的合成和线性组合来实现的。此外，除了通常的标量特征流之外，网络还能保持矢量特征流，并使用算子在流内和流之间进行通信。</li> <li>我们提出了一种网络架构来实现我们的方法，并调整差分算子，使其在我们的网络中有效工作。</li> <li>我们实施并评估了点云网络，并提出了应对点云学习中普遍存在的采样不足区域、噪声和信息缺失的技术。</li> </ul> <h2 id="相关工作">相关工作</h2> <p>我们将对相关工作的讨论集中在最相关的主题上。请参考有关几何深度学习[Bronstein 等人，2021 年，2017 年]和点云学习[Guo 等人，2020 年；Liu 等人，2019d]的调查报告，以了解这一不断扩展的领域的更全面概述。</p> <h3 id="点云网络和各向异性">点云网络和各向异性</h3> <p>点云数据学习的常见方法是使用多层感知器（MLP）学习每个点的特征，然后进行局部或全局聚合。许多方法也会在最大聚合之前学习局部点对的特征。著名的例子有 PointNet 及其后继者 PointNet++ [Qi 等人，2017a,b]。一些后续研究通过增加更多的点对特征组合等方法提高了速度和精度[Le 等人，2020 年；Liu 等人，2020 年；Lu 等人，2021 年；Qiu 等人，2021a；Sun 等人，2019 年；Xu 等人，2021b；Yang 等人，2019 年；Zhao 等人，2019 年]。其中一些点向 MLP 通过拆分每个三维轴的 MLP 来明确编码各向异性[Lan 等人，2019 年；Liu 等人，2020 年]。来自变压器的概念 [Vaswani 等人，2017 年] 也已进入点云领域 [Lin 等人，2020 年；Zhang 等人，2021 年；Zhao 等人，2021 年]。这些网络使用自我关注来计算（相邻）点的聚合权重。通过添加三维空间的相对位置，将空间信息纳入其中。在我们的方法中，基于注意力的聚合可以用来替代最大聚合。点与点之间的距离可以作为内在的空间编码。</p> <h3 id="伪网格卷积是将图像卷积更直接地转换成点云">伪网格卷积是将图像卷积更直接地转换成点云</h3> <p>其中许多是在三维空间中定义的，因此支持三维坐标中的各向异性。有几项研究学习了连续核，并将其应用于局部点云区域[Atzmon等人，2018；Boulch，2020；Fey等人，2018；Hermosilla等人，2018；Liu等人，2019a,b；Thomas等人，2019；Wu等人，2019；Xu等人，2021a]。还有一些人学习离散核，并将局部区域的点映射到离散网格中 [Choy 等人，2019 年；Graham 等人，2018 年；Hua 等人，2018 年；Lei 等人，2019 年；Li 等人，2018 年]。我们通过建立本征卷积，进入了一个正交方向，本征卷积在更少的维度上运行，并自然地泛化为（非）刚性变形形状。</p> <p>最后，基于图的方法从输入集创建 k 近邻图或半径图，并应用图卷积 [Chen 等人，2020 年；Dominguez 等人，2018 年；Feng 等人，2019 年；Liu 等人，2019 年 c；Pan 等人，2018 年；Shen 等人，2018 年；Simonovsky 和 Komodakis，2017 年；Te 等人，2018 年；Wang 等人，2018 年、2019 年；Zhang 等人，2019 年；Zhang 和 Rabbat，2018 年]。DGCNN [Wang 等人，2019] 引入了 EdgeConv 算子和动态图组件，可以重新连接网络内部的 k 近邻图。EdgeConv 计算特征差异的最大值，这使得网络可以在其通道中表示方向。如果将空间坐标作为输入，通道方向就会类似于空间方向，而 DGCNN 仅在第一层才会出现这种情况。相比之下，我们的卷积算法直接在算子中支持各向异性。</p> <h3 id="旋转等变方法">旋转等变方法</h3> <p>在点云和网格的旋转等变方法中，也使用了具有双流和矢量值特征的架构。一组作品研究了三维空间中的旋转等变，旨在设计不受刚性点云变换影响的网络[Cohen 等人，2018 年；Esteves 等人，2017 年；Poulenard 等人，2019 年；Thomas 等人，2018 年]。这一概念也被纳入变压器设置中[Fuchs 等人，2020]。旋变核通常输出向量值特征。矢量神经元通过线性组合三维矢量，再加上矢量非线性，简化了矢量神经元的使用[Deng 等人[n.d.]]。我们对向量 MLP 的使用与此类似。不同之处在于，我们使用的是切向矢量，而不是三维矢量，而且我们在网络内部使用几何运算符推导这些矢量。</p> <p>另一种方法是利用网格上的固有旋转量变卷积建立网络[Cohen 等人，2019 年；de Haan 等人，2021 年；Gerken 等人，2021 年；Poulenard 和 Ovsjanikov，2018 年；Weiler 等人，2021 年；Wiersma 等人，2020 年]。这些网络使用局部参数化，并在参数域中应用旋转或轨则变量核，以实现与切线空间中基数选择的独立性。我们的方法是轨则参数网络的替代方案。微分算子的使用也使我们的网络不受局部坐标系选择的影响。我们这种方法的一个好处是不需要局部参数化。举例来说，轨则参数方法通常使用指数图进行局部参数化，但忽略了参数化引起的角度变形。据我们所知，我们是第一个在点云上实现和评估内在双流架构的人。</p> <h3 id="几何算子">几何算子</h3> <p>多位作者使用几何算子构建卷积。图-拉普拉斯算子用于 GCN [Kipf and Welling 2017]。用于图形学习的光谱网络基于图-拉普拉奇的特征对[Bruna 等人，2014 年]。用于三角形网格的曲面网络 [Kostrikov 等人，2018] 将拉普拉斯与外在狄拉克算子交错在一起 [Liu 等人，2017]。Parametrized Differential Operators (PDOs) [Jiang 等人，2019] 使用梯度和发散算子来学习非结构网格上的球形信号。DiffGCN [Eliasof and Treister 2020] 使用梯度和发散算子的有限差分方案来构建图网络。DiffusionNet [Sharp 等人，2021 年] 使用拉普拉斯-贝尔特拉米算子和梯度方向特征学习扩散。DeltaConv 使用更多的算子集，将向量微积分中的算子进行组合和串联。此外，它还允许处理向量值特征流中的方向信息。一种相关的方法是 HodgeNet [Smirnov and Solomon 2021]，它可以学习使用微分算子的结构来构建算子。在深度学习之外，微分算子被广泛应用于三维形状分析 [Crane 等人，2013a；de Goes 等人，2016]。</p> <h2 id="方法">方法</h2> <p>我们通过学习几何微分算子的组合来构建各向异性卷积。由于这些算子定义在标量场和矢量场上，因此我们将网络分为标量特征和矢量特征。在本节中，我们将介绍这两种流、算子及其离散化方式，以及算子组合的学习方式。最后，我们将讨论这一结构所产生的特性。</p> <p><strong>流</strong>，考虑一个点云 \(P \in \mathbb{R}^{N \times 3}\)，它由 \(N\) 个点组成的一个 \(N \times 3\) 矩阵排列而成。所有点都可以与 \(C\) 个额外特征相关联，这些特征存储在一个矩阵 \(X \in \mathbb{R}^{N \times C}\) 中。在网络内部，我们将第 \(l\) 层在第 \(i\) 个点的特征称为 \(x_i^{(l)} \in \mathbb{R}^{C_l}\)。所有这些特征构成了标量流（scalar stream）。</p> <p>矢量流（vector stream）与标量流并行运行。矢量流中的每个特征是一个切向量，通过系数 \((\alpha_i^u, \alpha_i^v)\) 编码，这些系数相对于相应切平面中的基。基可以是任意一对与法向量正交的标准正交向量。系数对每个点交错排列，形成特征矩阵 \(V^{(l)} \in \mathbb{R}^{2N \times C_l}\)，其中 \(V^{(l)}\) 的一列是系数：\([\alpha_1^u, \alpha_1^v, \ldots, \alpha_i^u, \alpha_i^v, \ldots, \alpha_N^u, \alpha_N^v]^T\)。矢量流的输入是在每个点定义的矢量场。在我们的实验中，我们使用输入到标量流的梯度作为矢量流的输入。我们将分别称 \(X\) 和 \(V\) 的连续对应物为 \(X\) 和 \(V\)。</p> <blockquote> <p>在点云上，每一个点都可以具备各种属性或特征，这些特征可以是标量的，也可以是矢量的</p> <p>比如，一辆汽车表面离散化出来的点云模型，每个点上都可以有：1. 标量特征，温度、颜色、湿度；2. 矢量特征，风速等等</p> </blockquote> <h3 id="标量到标量最大聚合">标量到标量：最大聚合</h3> <p>在标量流内部应用了一个简化版的基于点的 MLP（多层感知机），基于 PointNet++ [Qi et al. 2017b] 和 EdgeConv [Wang et al. 2019]。我们对每个点应用一个 MLP 然后对一个 \(k\)-最近邻居 \(\mathcal{N}(i)\) 执行最大值聚合。标量流中的特征被计算为</p> \[x_i^{(l+1)} = h_{\theta_0}\left(x_i^{(l)}\right) + \max_{j \in \mathcal{N}(i)} h_{\theta_1}\left(x_j^{(l)}\right)\] <p>其中 \(h_{\theta_0}\) 和 \(h_{\theta_1}\) 表示多层感知机（MLP），由全连接层、批量归一化 [Ioffe and Szegedy 2015] 和非线性函数组成。如果点位置被用作输入，它们会在最大聚合之前中心化：\(\hat{p}_j = p_j - p_i\)。</p> <p>与 EdgeConv 和 PointNet++ 最大的不同是，我们在网络中只使用基于点的特征，而不是基于边的特征。因此，MLP 内部使用的矩阵乘法不是应用于\(kN\)个特征向量，而是应用于\(N\)个点特征向量。这对前向和后向传递的运行时间有很大影响。方向信息是用每点向量而不是边来编码的。</p> <blockquote> <p>这个过程主要在于：1. MLP混合标量特征组成的向量， 2. 提取K近邻中最大值做局部特征捕捉</p> <p>这里特别强调：1. 如果使用的是位置信息，要相对距离化，2. 不使用基于边的特征，即不侧重于点与点之间的关系和相互作用</p> </blockquote> <h3 id="标量到矢量梯度与余梯度">标量到矢量：梯度与余梯度</h3> <p>梯度和余梯度算子连接标量流到矢量流。一个函数的梯度代表了在每个点最大的变化率及其变化方向的向量。余梯度是梯度的 90 度旋转。结合起来，梯度和余梯度跨越了切平面，允许网络对梯度向量进行缩放、倾斜和旋转。</p> <p>我们使用一个移动最小二乘法构建了一个离散的梯度算子，该方法在具有 \(k\) 邻居的邻域上使用 [Nealen 2004]。这种方法用于对点云进行建模和处理，以及在点云上解微分方程 [Crane et al. 2013b; Liang 和 Zhao 2013]。该过程和伴随理论概述在补充材料中。梯度算子被表示为一个稀疏矩阵 \(G \in \mathbb{R}^{2N \times N}\)。它接受 \(N\) 个值代表点上的特征，并输出 \(2N\) 个值代表每个点的切线基系数中的梯度。矩阵非常稀疏，因为它每行只包含 \(2k\) 个元素。余梯度算子 \(JG\) 是梯度与一个块对角稀疏矩阵 \(J \in \mathbb{R}^{2N \times 2N}\) 的组合，其中 \(J\) 的每个块是一个 \(2 \times 2\) 的 90 度旋转矩阵。</p> <p>点云通常包含欠采样区域和噪声。这对移动最小二乘法过程可能是个问题。考虑图 3 中的一个例子，一把腿细的椅子。只有少数点沿着构成椅子腿的线排列。因此，垂直于线的方向是欠采样的，导致在一个不稳定的最小二乘拟合中：一点的微小扰动可能严重影响结果（左侧，圈出区域）。我们通过添加一个由 \(\lambda\) 缩放的正则化项到最小二乘拟合过程中，试图减轻这种效应（右侧）。这是一个被称为岭回归或Tikhonov正则化的已知技术。</p> <p>我们还主张梯度算子应该被规范化，这一观点是由信息在网络中如何融合激发的。如果 \(G\) 表现出发散或收敛行为，由 \(G\) 产生的特征也将发散或收敛。当梯度在网络中被多次应用时，这是不可取的。由梯度操作产生的特征将具有不同的数量级，网络权重需要考虑这一点。因此，我们通过 \(\ell^{\infty}\) 算子范数规范化 \(G\)，提供了一个操作子缩放行为的上界</p> \[\hat{G} = \frac{G}{\|G\|_{\infty}}, \quad \text{其中} \|G\|_{\infty} = \max_i \sum_j \|G_{ij}\|\] <div class="row mt-3"> <div class="col-12 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/202404/deltaconv_3-480.webp 480w,/assets/img/202404/deltaconv_3-800.webp 800w,/assets/img/202404/deltaconv_3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/202404/deltaconv_3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 3. 椅子上 x 坐标的梯度，未进行正则化处理（左图），已进行正则化处理（右图）。 </div> <h3 id="矢量到标量散度旋度和范数">矢量到标量：散度、旋度和范数</h3> <p>矢量流通过散度、旋度和范数连接回标量流。这些算子通常用来分析矢量场，并指示诸如汇点、源点、旋涡以及矢量场的强度等特征。网络可以使用它们作为各向异性算子的构建块。 离散散度也是用移动最小二乘法构建的，该方法在补充材料中有描述。散度表示为一个稀疏矩阵 \(D \in \mathbb{R}^{N \times 2N}\)，有 \(2kN\) 个元素。旋度被导出为 \(-DJ\)。</p> <h3 id="矢量到矢量hodge-laplacian">矢量到矢量：Hodge Laplacian</h3> <p>矢量特征在矢量流中通过身份矩阵 \(I\) 和 Hodge Laplacian \(\Delta\) 的组合进行扩散。将 Hodge Laplacian 应用于矢量场 \(V\) 会得到另一个矢量场，它编码了每个点及其邻居的矢量之间的差异。Hodge Laplacian 可以被构造为梯度（grad）、散度（div）、旋度（curl）和 \(\mathcal{J}\) 的组合 [Brandt et al. 2017]。</p> \[\Delta = -(\text{grad div} + \mathcal{J} \text{ grad curl})\] <p>在离散设置中，我们用其离散变体替换每个算子，</p> \[L = -(GD - JGDJ)\] <h3 id="为什么选择这些算子">为什么选择这些算子？</h3> <p>我们使用的算子在本质上是相互关联的。它们构成了表面 de Rham 复合体的一个度量版本 [Wardetzky 2006]。以下图表阐述了前面章节中描述的连接，每个算子都在函数（标量场）和矢量场之间进行映射。</p> <div class="row mt-3"> <div class="col-12 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/202404/deltaconv_fun_1-480.webp 480w,/assets/img/202404/deltaconv_fun_1-800.webp 800w,/assets/img/202404/deltaconv_fun_1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/202404/deltaconv_fun_1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>请注意，底行是顶行的一个 90 度旋转版本。如果我们按照从左到右的图表应用 grad 然后是 curl 到任何函数，输出将总是零。从右到左的路径也是如此。列出的算子是一阶导数。拉普拉斯算子，作为二阶导数，可以通过组合一阶算子形成。对于函数：用 grad 和 div 再次返回矢量场（Laplace-Beltrami）。对于矢量场：我们用 div 和 curl 去到标量，然后再用 grad 和 co-grad 返回（Hodge-Laplacian）。DeltaConv 学会组合这些算子，并通过添加非线性项支持各向异性。</p> <h3 id="deltaconv学习各向异性算子">DeltaConv：学习各向异性算子</h3> <p>每个操作要么输出标量值特征，要么输出矢量值特征。我们连接每个流中属于它的所有特征，然后用参数化函数组合这些特征</p> \[v_i' = h_{\theta_0}(v_i, (GX)_i, (LV)_i)\] \[x_i' = h_{\theta_1}(x_i, (DV)'_i, (-DJV)'_i, ||v'_i||) + \max_{j \in \mathcal{N}_i} h_{\theta_2}(x_j). \quad (6)\] <p>我们使用撇号来表示 \(l+1\) 层的特征。所有其他特征来自于层 \(l\)。\(h_{\theta_1}\) 和 \(h_{\theta_2}\) 表示标准 MLPs。\(h_{\theta_0}\) 表示用于矢量的 MLP。矢量 MLP 能够缩放和求和矢量，公式（6）。</p> <div class="row mt-3"> <div class="col-12 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/202404/deltaconv_4-480.webp 480w,/assets/img/202404/deltaconv_4-800.webp 800w,/assets/img/202404/deltaconv_4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/202404/deltaconv_4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 图 4. DeltaConv 原理图 </div> <p>这意味着它们不对单独的向量系数工作，并且是坐标无关的。回想一下，\(V \in \mathbb{R}^{2N\times C^{(l)}}\)将每个点的向量系数交织在列中。向量MLP被应用到\(V\)上，如下所示：</p> \[V' = \sigma(VW)\quad (7)\] <p>其中 \(W \in \mathbb{R}^{C^{(l)}\times C^{(l+1)}}\)是一个权重矩阵，而 \(\sigma\)是一个非线性函数。矩阵乘法将 \(W\)与向量范数相结合，线性组合了向量特征，但向量的单个系数并没有混合。在向量MLP被应用之前，我们将输入特征的90度旋转向量连接起来。这使得MLP也能旋转向量特征，并且丰富了操作符集合。例如，90度旋转的梯度是共梯度。向量MLP可以学习结合来自局部邻域的信息（通过梯度和霍奇-拉普拉斯算子），以及来自不同通道的信息（通过恒等函数）。方程6的示意图可以在图4中找到。</p> <p>虽然方程6以MLP和特征串联的形式表述了DeltaConv，另一种观点是将方程6中的操作视为线性组合基本操作符，并在它们之间用非线性函数进行组合，以形成各向异性的几何运算符。</p> <h3 id="deltaconv-的属性">DeltaConv 的属性</h3> <p>DeltaConv的构建模块，例如梯度、散度和旋度，以及它们与非线性的结合，使DeltaConv能够构建非线性各向异性卷积滤波器。这一点通过Perona-Malik滤波器在图2中的例子来说明。向量流还允许DeltaConv处理向量特征及其相对方向，直接使用相应的运算符。</p> <p>DeltaConv的公式是以光滑的微分运算符为基础，不限于特定的表面表示。在这项工作中，我们为点云和图像实现了DeltaConv，然而，这些概念可以推广到其他表现形式。例如，对于网格，可以使用有限元离散化[Brandt et al. 2017]或离散外微积分[Crane et al. 2013a]来实现。</p> <p>DeltaConv是坐标无关的，这意味着在DeltaConv中使用的权重并不依赖于切线基底的选择。例如，对同一形状的前向传递，如果基底的选择不同，仍然会导致相同的输出和权重更新。与坐标无关的原因在于，DeltaConv 中的所有基本操作，如应用几何算子和向量 MLP，都与坐标无关。据微分几何学所知，无论选择哪个基，都可以得到相同的几何运算结果[O’Neill 1983]。这个属性通过运算符的离散化得以保留，因此DeltaConv也继承了这一属性。</p> <p>最后，DeltaConv的每一个构建模块都是等距不变的。这意味着如果一个形状发生了等距变形，DeltaConv是不会改变的。这个属性对于那些形状发生刚性或非刚性变形的任务是有益的。如果表面方向被翻转，切线平面中的旋转也会翻转。如果仅使用梯度和散度，DeltaConv对此具有鲁棒性。</p> <h2 id="实验">实验</h2> <p>我们通过与最新技术在分类和分割上的比较来验证我们的方法。此外，我们进行消融研究，以便更深入地了解向量流对各向异性、准确性和效率的影响。</p> <h3 id="实施细节">实施细节</h3> <p>在我们的实验中，我们使用基于DGCNN [Wang et al. 2019]的网络架构。我们用DeltaConv块替换了每个EdgeConv块（见图4），并且没有使用动态图组件。这些网络在局部邻域上单一尺度运作。尽管架构简单，DeltaConv仍然实现了最先进的结果。为了展示架构优化对DeltaConv的意义，我们还测试了在KPFCNN [Thomas et al. 2019]中使用的U-ResNet架构，但是将编码器中的卷积块用DeltaConv块替换。在下采样块中，我们通过平行运输池化向量特征[Wiersma et al. 2020]。更多细节在补充材料中提供。代码可在 <a href="https://github.com/rubenwiersma/deltaconv">deltaconv</a> 上获取。</p> <p>数据变换。对于每个形状，计算一个k-n图，用于标量流中的最大化聚合。当必要时，它被用来估算法线并构建梯度。在每项实验中，我们将xyz坐标作为输入来使用网络，并且使用随机尺度和平移，类似于先前工作的数据增强。一些数据集需要特定的增强，这些在它们各自的部分有详细说明。</p> <p>训练。网络中的参数通过随机梯度下降（SGD）进行优化，初始学习率为0.1，动量为0.9，并设定了一个0.0001的终止学习率。参数使用余弦退火调度器[Loshchilov and Hutter 2017]更新，这会将学习率降低到0.001。</p> <h2 id="附录">附录</h2> <h3 id="a离散化算子">A.离散化算子</h3> <p><strong>梯度</strong>。我们通过[Liang 和 Zhao 2013]的方法构建一个离散梯度，使用移动最小二乘法。我们逐步演示了如何从黎曼几何的一般公式开始导出梯度，并在设置允许的情况下简化术语。</p> <p>我们在局部拟合一个表面块来估计每个点 \(p\) 的度量，使用移动最小二乘法 [Nealen 2004]。表面块 \(\Gamma: \mathbb{R}^2 \rightarrow \mathbb{R}^3\)，通常称为蒙日(Monge)块，用二次多项式 \(h(u, v)\) 来描述点 \(p\) 处的切平面上的表面，其给出公式为：</p> \[\Gamma(u, v) = [u, v, h(u, v)]^T \quad (8)\] <p>其中，\(u, v\) 表示切平面中的局部坐标。由于表面块应该插值点 \(p\) 和表面法线，因此点 \(p\) 处的块的法线应该与切平面的法线一致，\(h(u, v)\) 的常数项和线性项消失。</p> \[h(u, v) = \alpha_1 u^2 + \alpha_2 uv + \alpha_3 v^2 \quad (9)\] \[h_u = 2\alpha_1 u + \alpha_2 v \quad (10)\] \[h_v = \alpha_2 u + 2\alpha_3 v \quad (11)\] <p>度量给出为：</p> \[g = \begin{bmatrix}1 + h_u^2 &amp; h_uh_v \\h_uh_v &amp; 1 + h_v^2\end{bmatrix} \quad (12)\]]]></content><author><name></name></author><category term="Trans"/><category term="Math"/><category term="NeuralNetwork"/><summary type="html"><![CDATA[DeltaConv]]></summary></entry><entry><title type="html">Linux Basic Command Manual</title><link href="https://sirenexcelsior.github.io/blog/2024/linux-common/" rel="alternate" type="text/html" title="Linux Basic Command Manual"/><published>2024-04-01T00:00:00+00:00</published><updated>2024-04-01T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/linux-common</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/linux-common/"><![CDATA[<h2 id="file-and-directory-operations">File and directory operations</h2> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">ls</code></strong> - <strong>List</strong>: This command lists the contents of a directory. The name “list” succinctly describes its primary function, which is to display files and directories.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="c"># list the contents of a directory</span>
<span class="nb">ls</span> <span class="nt">-l</span> <span class="c"># show detailed information</span>
<span class="nb">ls</span> <span class="nt">-a</span> <span class="c"># show hidden files</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">cd</code></strong> - <strong>Change Directory</strong>: The <code class="language-plaintext highlighter-rouge">cd</code> command is used to change the current working directory in a shell. The term “change directory” directly reflects its purpose of moving from one directory to another.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /path/to/directory <span class="c"># switch to the specified directory</span>
<span class="nb">cd</span> .. <span class="c"># to return to parent directory</span>
<span class="nb">cd</span> ./path <span class="c"># switch to the specified directory within the current directory</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">pwd</code></strong> - <strong>Print Working Directory</strong>: This command outputs the full pathname of the current working directory. “Print working directory” accurately describes the action of displaying the directory you’re currently in.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">pwd</span> <span class="c"># display the full path of the current directory</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">mkdir</code></strong> - <strong>Make Directory</strong>: The <code class="language-plaintext highlighter-rouge">mkdir</code> command creates a new directory. The name “make directory” is a straightforward indication of its function to create (or “make”) a new directory.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>new_directory <span class="c"># creating a new catalogue</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">rmdir</code></strong> - <strong>Remove Directory</strong>: This command is used to delete empty directories. The name “remove directory” clearly states that it removes directories, emphasizing that it only works on empty ones.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rmdir </span>directory_name <span class="c"># delete empty directories</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">rm</code></strong> - <strong>Remove</strong>: Unlike <code class="language-plaintext highlighter-rouge">rmdir</code>, the <code class="language-plaintext highlighter-rouge">rm</code> command is used to remove files or directories (the latter requires an option to do so recursively). The term “remove” is generic because it applies to both files and directories.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm </span>file_name <span class="c"># delete a file</span>
<span class="nb">rm</span> <span class="nt">-r</span> directory_name <span class="c"># recursive deletion of directories and their contents</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">cp</code></strong> - <strong>Copy</strong>: The <code class="language-plaintext highlighter-rouge">cp</code> command is used to copy files and directories. The term “copy” directly reflects its purpose to duplicate files or directories from one location to another.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> /source /destination <span class="c"># copy the source file to the target location</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">mv</code></strong> - <strong>Move</strong>: This command moves or renames files and directories. The name “move” is apt because it can move files or directories to a new location or simply rename them within their current directory.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mv</span> /source /destination <span class="c"># moving or renaming files or directories</span>
</code></pre></div> </div> </li> </ul>]]></content><author><name></name></author><category term="Notebooks"/><category term="Linux"/><category term="NeuralNetwork"/><summary type="html"><![CDATA[Chapter 1 of Linux Trivia]]></summary></entry><entry><title type="html">All Task of Assembly Language 2024</title><link href="https://sirenexcelsior.github.io/blog/2024/as-code/" rel="alternate" type="text/html" title="All Task of Assembly Language 2024"/><published>2024-03-30T00:00:00+00:00</published><updated>2024-03-30T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/as-code</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/as-code/"><![CDATA[<p>This is a site for the record of all test answers for the course <a href="https://scs.math.msu.ru/node/4281">Assembly Language</a>, Spring 2024, taught by Леонов Александр Георгиевич, on the online course platform <a href="https://mirera.ru/user/groups/65cb80e98cd5ad641f4efb8b">mirera.ru</a>.</p> <p>You can see some of the points about the classroom in “<a href="https://sirenexcelsior.github.io/blog/2024/as-point/">Some points about Assembly Language 2024</a>”.</p> <h2 id="lecture-01">Lecture 01</h2> <h3 id="0-example">0 (Example)</h3> <pre><code class="language-assembly">MOV AX,0	; Move 0 to register AX, i.e., assign the value
</code></pre> <h3 id="2000">2000</h3> <p>Write a program that puts 2000 in the AX register.</p> <pre><code class="language-assembly">MOV AX, 2000
</code></pre> <h3 id="data">Data</h3> <p>Write a program that puts data from BX in the AX register.</p> <pre><code class="language-assembly">MOV AX, BX
</code></pre> <h3 id="sum-example">Sum (Example)</h3> <p>Run the program that puts the sum of data from BX and CX into the AX register.</p> <pre><code class="language-assembly">MOV AX,BX
ADD AX,CX
</code></pre> <h3 id="subtract">Subtract</h3> <p>Write a program that places the result of subtracting data CX from BX into register AX.</p> <pre><code class="language-assembly">SUB BX, CX
MOV AX, BX
</code></pre> <h3 id="calculate">Calculate</h3> <p>Write a program that places the result of operation into register AX.</p> <pre><code class="language-assembly">MOV AX, 0
MOV BX, FF00
MOV CX, F
MOV DX, F1

AND CX, DX
OR  CX, 80

MOV AX, BX
OR  AX, C0
ADD AX, CX
NEG AX
</code></pre> <h3 id="swap">Swap</h3> <p>Write a program that swaps two numbers in registers BX and CX.</p> <pre><code class="language-assembly">MOV AX, BX
MOV BX, CX
MOV CX, AX
</code></pre> <h3 id="swap-return">Swap Return</h3> <p>Write a program that swaps two numbers in registers BX and CX (Not use Push/Pop or other registers)!</p> <pre><code class="language-assembly">ADD BX, CX
SUB CX, BX
NEG CX
SUB BX, CX
</code></pre> <h3 id="not">NOT</h3> <p>Bitwise Unary NOT (~) performs <em>complementation</em> or <em>negation</em> operation; inverts all the bits of the number, i.e. <em>0→1</em> and <em>1→0</em>.</p> <ul> <li> <p>Truth table:</p> <table> <thead> <tr> <th style="text-align: center"><strong>A</strong></th> <th style="text-align: center"><strong>~ A</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center">0</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">1</td> <td style="text-align: center">0</td> </tr> </tbody> </table> </li> </ul> <p>Write a program that places the result of operation NOT into register AX. (Not use Push/Pop or other registers)!</p> <pre><code class="language-assembly">NEG AX
DEC AX
</code></pre> <h3 id="remember">Remember!</h3> <p>Write a program that stores two numbers in registers BX and CX between operations.</p> <pre><code class="language-assembly">PUSH BX
PUSH CX

MOV DX,0
MOV CX,0
MOV BX,0
MOV AX,0

POP CX
POP BX
</code></pre> <h3 id="xor">XOR</h3> <p>Exclusive or or exclusive disjunction is a logical operation that is true if and only if its arguments differ (one is 1, the other is 0). Exclusive disjunction is often used for bitwise operations. Examples:</p> <ul> <li>1 XOR 1 = 0</li> <li>1 XOR 0 = 1</li> <li>0 XOR 1 = 1</li> <li>0 XOR 0 = 0</li> </ul> <p>Write a program that places the result of operation AX XOR BX into register AX. (Not use Push/Pop or all other registers, you can use only one extra register - CX)!</p> <pre><code class="language-assembly">MOV CX, AX
OR  AX, BX
AND BX, CX
NEG BX
DEC BX
AND AX, BX
</code></pre> <h3 id="left-shift-example">Left Shift (Example)</h3> <p>Run the program that multiply by 2 a number in the AX register.</p> <p><em>Do Not forget CLC before any RCL!</em></p> <pre><code class="language-assembly">CLC
RCL AX
END
</code></pre> <h3 id="right-shift">Right Shift</h3> <p>Write a program that divides by 2 the number in register CX and puts the result in register AX.</p> <p><em>Do Not forget CLC before any RCR!</em></p> <pre><code class="language-assembly">CLC
RCR CX
MOV AX, CX
</code></pre> <h3 id="multishift">MultiShift</h3> <p>Write a program that puts the value of AX multiplied by 4 into register BX and the value of AX divided by 4 into register CX.</p> <p>Use the shift operations RCL and RCR.</p> <p><em>Do Not forget CLC before any RCL and RCR!</em></p> <pre><code class="language-assembly">MOV BX, AX
MOV CX, AX

CLC
RCL BX
CLC
RCL BX

CLC
RCR CX
CLC
RCR CX
</code></pre> <h3 id="sum">Sum</h3> <p>Write a program that puts into register AX the sum of two 8-bit numbers stored in 16-bit register BX.</p> <p>Example: BX = \(032E_{16}\), result AX = \(03_{16} + 2E_{16}\) = \(31_{16}\).</p> <p>If BX=0, then AX=0.</p> <p>Use the shift operations RCL or RCR.</p> <p><em>Do Not forget CLC before any RCL and RCR!</em></p> <pre><code class="language-assembly">MOV AX, BX
AND AX, 00FF
MOV CX, BX

CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX

ADD AX, CX

END
</code></pre> <h2 id="lecture-02">Lecture 02</h2> <h3 id="zero-comparison-example">Zero Comparison (Example)</h3> <p>Run a program that compares BX and CX and sets AX=1 when BX = CX</p> <pre><code class="language-assembly">CMP BX,CX
JNZ ?1
MOV AX,1
?1:
</code></pre> <h3 id="comparing-two-numbers">Comparing two numbers</h3> <p>Write a program that puts 1 in register AX if BX \(\ge\) CX and 0 otherwise.</p> <pre><code class="language-assembly">CMP BX, CX
JC  ?01
MOV AX, 1
JMP ?02
?01:
MOV AX, 0
?02:
</code></pre> <h3 id="absolute-value">Absolute value</h3> <p>Write a program to put the absolute value of the difference between the numbers in BX and CX into register AX.</p> <pre><code class="language-assembly">CMP BX, CX
JNC ?01
SUB CX, BX
MOV AX, CX
JMP ?02
?01:
SUB BX, CX
MOV AX, BX
?02:
</code></pre> <h3 id="minimum">Minimum</h3> <p>Write a program that puts the minimum number of numbers from BX and CX into AX.</p> <pre><code class="language-assembly">CMP BX, CX
JC  ?01
MOV AX, CX
JMP ?02
?01:
MOV AX, BX
?02:
</code></pre> <h3 id="divisible-by-3">Divisible by 3</h3> <p>Write a program that puts 1 in register AX if BX is evenly divisible by 3, and 0 otherwise.</p> <pre><code class="language-assembly">MOV AX, BX
MOV CX, 3
JZ  ?03
?01:
SUB AX, 0
JZ  ?03
CMP AX, CX
JC  ?02
JZ  ?03
SUB AX, CX
JMP ?01

?02:
MOV AX, 0
JMP ?04

?03:
MOV AX, 1

?04:
</code></pre> <h3 id="divisible-by-2">Divisible by 2</h3> <p>Write a program that puts 1 in register AX if BX is evenly divisible by 2, and 0 otherwise.</p> <p>(Do not use all other registers, except AX and BX or any Jump command)!</p> <pre><code class="language-assembly">MOV AX, 1
AND BX, 1
SUB AX, BX
</code></pre> <h3 id="bit-number">Bit number</h3> <p>Bits in a 16-bit register are numbered from 1 (least significant bit) to 16. Write a program that finds the least significant non-zero bit number of register BX and puts the answer into register AX.</p> <p>If BX=0, then AX=0.</p> <p>Use the RCR shift operation.</p> <p>Example: BX=\(0006_{16}\) (0000 0000 0000 01102), AX=2.</p> <pre><code class="language-assembly">MOV CX, 0
MOV AX, BX

OR  AX, AX
JZ  ?01
MOV CX, 1

?02:
RCR BX
JC  ?03
INC CX
JMP ?02

?03:
MOV AX, CX
JMP ?04

?01:
MOV AX, 0

?04:
</code></pre> <h3 id="number-of-different-numbers">Number of different numbers</h3> <p>Write a program that puts in register AX the number of different numbers in BX, CX, DX.</p> <p>Example:</p> <ul> <li>DX = 0</li> <li>BX = 1</li> <li>CX = 2</li> <li>Answer AX = 3</li> </ul> <pre><code class="language-assembly">MOV AX, 3
CMP BX, CX
JNZ ?01
DEC AX

?01:
CMP BX, DX
JNZ ?02
DEC AX

?02:
CMP CX, DX
JNZ ?03
DEC AX

?03:
CMP AX, 1
JNC ?04
MOV AX, 1

?04:
</code></pre> <h3 id="number-of-maximum">Number of maximum</h3> <p>Write a program that counts the maximums in the sequence BX, CX, DX and places the result in the AX register. For example, in the sequence of numbers 1,2,3 - the maximum is unique and equals 3 (BX=1, CX=2, DX=3 ⇒ AX=1) In the sequence of numbers 3,1,3 - the maximum is 3 and there are 2 such numbers in the sequence (BX=3, CX=1, DX=3 ⇒ AX=2).</p> <pre><code class="language-assembly">MOV AX, 1
?00:
CMP BX, CX
JC  ?01
JZ  ?02
?03:
CMP BX, DX
JC  ?04
JZ  ?05
JMP ?06
?01:
MOV BX, CX
MOV AX, 1
JMP ?03
?02:
INC AX
JMP ?03
?04:
MOV BX, DX
MOV AX, 1
JMP ?06
?05:
INC AX
JMP ?06
?06:
</code></pre> <h3 id="sides-of-a-triangle">Sides of a triangle</h3> <p>Can non-negative integers in BX, CX, DX be sides of a triangle?</p> <p>The result will be AX=1 if YES and AX=0 if NOT.</p> <pre><code class="language-assembly">ADD BX, CX
MOV AX, BX
SUB BX, CX
SUB AX, DX
JZ  ?00
JC  ?00
MOV AX, 1

ADD BX, DX
MOV AX, BX
SUB BX, DX
SUB AX, CX
JZ  ?00
JC  ?00
MOV AX, 1

ADD CX, DX
MOV AX, CX
SUB CX, DX
SUB AX, BX
JZ  ?00
JC  ?00
MOV AX, 1
JMP ?03

?00:
MOV AX, 0

?03:
</code></pre> <h3 id="right-triangle">Right triangle</h3> <p>Can non-negative integers in BX, CX, DX be sides of a right triangle?</p> <p>The result will be AX=1 if yes, and AX=0 if not.</p> <p><em>Note</em>. A triangle with sides {0,0,0} is not a right triangle.</p> <pre><code class="language-assembly">PUSH DX
PUSH CX
MOV AX, BX
MOV CX, BX
DEC AX

?01:
ADD BX, CX
DEC AX
JZ  ?02
JMP ?01

?02:
POP CX
POP DX

PUSH BX
PUSH DX
MOV AX, CX
MOV BX, CX
DEC AX

?03:
ADD CX, BX
DEC AX
JZ ?04
JMP ?03

?04:
POP DX
POP BX

PUSH BX
PUSH CX
MOV AX, DX
MOV BX, DX
DEC AX

?05:
ADD DX, BX
DEC AX
JZ ?06
JMP ?05

?06:
POP CX
POP BX

MOV AX, 0

CMP BX, 0
CMP CX, 0
CMP DX, 0
JZ  ?07

ADD BX, CX
CMP BX, DX
JZ  ?09
SUB BX, CX

ADD BX, DX
CMP BX, CX
JZ  ?09
SUB BX, DX

ADD CX, DX
CMP CX, BX
JZ  ?09
SUB CX, DX
JMP ?07

?09:
MOV AX, 1
?07:
</code></pre> <h3 id="long-shift-to-the-left">Long shift to the left</h3> <p>Run a program that doubles a 32-bit number from the BX AX registers (lower part of AX).</p> <p>RCL shift operations are used.</p> <pre><code class="language-assembly">CLC
RCL AX
RCL BX
</code></pre> <h3 id="long-shift-to-the-right">Long shift to the right</h3> <p>Write a program that divides a 32-bit number from the BX AX registers (lower part of AX) by 4.</p> <p>RCR shift operations are used.</p> <pre><code class="language-assembly">RCR BX
RCR AX

RCR BX
RCR AX
</code></pre> <h3 id="adding-two-long">Adding two long</h3> <p>Write a program that adds a 32-bit long number stored in the CX, DX registers with a long number stored in the AX, BX registers.</p> <pre><code class="language-assembly">ADD BX, DX
JC  ?00
JMP ?01
?00:
INC AX
?01:
ADD AX, CX
</code></pre> <h3 id="bus-for-programmers">Bus for programmers</h3> <p>Bus tickets for programmers have a hexadecimal number. We call a ticket lucky if the sum of the two left hexadecimal digits is equal to the sum of the two right digits, for example ADE9. Example of an unsuccessful ticket: 7+8≠9+3. How many lucky ticket numbers are found from number BX to number CX, including borders?</p> <pre><code class="language-assembly">; Code to achieve the task goal: to determine whether a number is a lucky vote or not
; Method: Read four 4-bit binary numbers in sequence using 0 and 1 operations, and then use RCR to transfer the data to the real data.
; Then, judge whether the final result is 0 by adding and subtracting to determine whether it is a lucky number of votes.

SUB CX, BX          ; Subtract BX from CX, result stored in CX
ADD CX, 2           ; Add 2 to CX, adjusting the loop counter

?00: 
DEC CX              ; Decrement CX by 1
JZ ?03              ; Jump to label ?03 if CX is zero (end of loop condition)

MOV [1], BX         ; Store the value of BX into memory location addressed by 1
AND BX, 0F          ; Perform bitwise AND between BX and 0F, isolating the lowest 4 bits

MOV DX, BX          ; Move the result of AND operation into DX

MOV BX, [1]         ; Restore BX from memory location addressed by 1
AND BX, F0          ; Perform bitwise AND between BX and F0, isolating bits 4-7
CLC                 ; Clear carry flag to prepare for rotate operation
RCR BX              ; Rotate BX right through carry, shifting bits 4-7 to 0-3
RCR BX
RCR BX
RCR BX              ; Repeat rotation to complete the shift of bits 4-7 to 0-3

ADD DX, BX          ; Add the newly shifted bits in BX to DX

MOV BX, [1]         ; Restore BX from memory location addressed by 1
AND BX, F00         ; Perform bitwise AND between BX and F00, isolating bits 8-11
CLC                 ; Clear carry flag to prepare for rotate operation
RCR BX              ; Rotate BX right through carry, shifting bits 8-11 towards lower bit positions
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX              ; Repeat rotation to complete the shift of bits 8-11 to 0-3

SUB DX, BX          ; Subtract the shifted value in BX from DX

MOV BX, [1]         ; Restore BX from memory location addressed by 1
AND BX, F000        ; Perform bitwise AND between BX and F000, isolating bits 12-15
CLC                 ; Clear carry flag to prepare for rotate operation
RCR BX              ; Rotate BX right through carry, shifting bits 12-15 towards lower bit positions
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX              ; Repeat rotation to complete the shift of bits 12-15 to 0-3

SUB DX, BX          ; Subtract the final shifted value in BX from DX

CMP DX, 0           ; Compare DX with 0
JZ ?01              ; Jump to label ?01 if DX is zero (if comparison equals zero)
MOV BX, [1]         ; Restore BX from memory location addressed by 1
INC BX              ; Increment BX
JMP ?00             ; Jump back to start of loop at label ?00

?01: 
INC AX              ; Increment AX
MOV BX, [1]         ; Restore BX from memory location addressed by 1
INC BX              ; Increment BX
JMP ?00             ; Jump back to start of loop at label ?00

?03:                ; Label ?03, marks the end of the loop or a specific condition block
</code></pre> <div class="row mt-3"> <div class="col-12 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/AL02-15-480.webp 480w,/assets/img/AL02-15-800.webp 800w,/assets/img/AL02-15-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/AL02-15.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="lecture-03">Lecture 03</h2> <h3 id="contents-of-an-address">Contents of an Address</h3> <p>Write a program that puts the contents at address BX into register AX.</p> <pre><code class="language-assembly">MOV AX, [BX]
</code></pre> <h3 id="contents-of-2">Contents of 2</h3> <p>Write a program that gets the number plus 200 from the BX register. Place the result in the AX register.</p> <p>Example: BX=\(100_{16}\) ⇒ AX=\(300_{16}\)</p> <pre><code class="language-assembly">ADD BX, 200
MOV AX, BX
</code></pre> <h3 id="contents-of-an-address-3">Contents of an Address 3</h3> <p>Write a program that gets the number plus \(200_{16}\) located at address BX. Place the result in the AX register.</p> <pre><code class="language-assembly">ADD [BX], 200
MOV AX, [BX]
</code></pre> <h3 id="sum-of-three-numbers">Sum of three numbers</h3> <p>Write a program that puts the sum of the three numbers at addresses 0, 1, and 2 into register AX.</p> <pre><code class="language-assembly">ADD AX, [0]
ADD AX, [1]
ADD AX, [2]
</code></pre> <h3 id="amount-by-address">Amount by address</h3> <p>Write a program that substitutes into register AX the sum of three numbers located at addresses BX, BX+1, BX+2.</p> <pre><code class="language-assembly">ADD AX, [BX]
INC BX
ADD AX, [BX]
INC BX
ADD AX, [BX]
</code></pre> <h3 id="array-sum">Array Sum</h3> <p>Write a program that puts into register AX the sum of an array of length CX, starting at address BX.</p> <p>The sum of an empty array is 0.</p> <pre><code class="language-assembly">?00:
CMP CX, 0
JZ  ?01

ADD AX, [BX]
DEC CX
INC BX
JMP ?00

?01:
</code></pre> <h3 id="equal-array">Equal array</h3> <p>Write a program that puts 1 in register AX if all elements of an array of length CX are equal. The array starts at address BX. The answer is 1 if the array has length 0.</p> <pre><code class="language-assembly">MOV AX ,  1
MOV DX ,  [BX]

CMP CX ,  0
JZ  ?02
CMP CX ,  1
JZ  ?02

DEC CX
?00: 
CMP CX ,  0
JZ  ?02

INC BX
DEC CX

CMP DX ,  [BX]
JNZ ?01
JMP ?00

?01: 
MOV AX ,  0

?02: 
</code></pre> <h3 id="address-of-the-first-minimum-number">Address of the first minimum number</h3> <p>Write a program that places the address of the first minimum number in an array of length CX into register AX, starting at address BX.</p> <p>In the case of an empty sequence, the answer is 0.</p> <pre><code class="language-assembly">MOV AX, 0
CMP CX, 0
JZ  ?02

MOV AX ,  BX
MOV DX ,  [BX]

?00: 
CMP DX ,  [BX]
JC  ?01
JZ  ?01
MOV DX ,  [BX]
MOV AX ,  BX

?01: 
INC BX
DEC CX
JZ ?02
JMP ?00

?02: 
</code></pre> <h3 id="the-number-of-all-connected-increasing-subsequences">The number of all connected increasing subsequences</h3> <p>Write a program that count all connected increasing subsequences. Places the result of an array of length CX, starting at address BX nto register AX.</p> <p>In the case of an empty sequence, the answer is 0.</p> <p>Example: 1 2 3 2 3 1 ⇒ AX=3.</p> <pre><code class="language-assembly">MOV AX ,  0
CMP CX ,  0
JZ  ?02

MOV AX , 1
MOV DX ,  [BX]
INC BX

?00: 
DEC CX
CMP CX ,  0
JZ  ?02
CMP DX ,  [BX]
JZ  ?01
JNC  ?01
MOV DX ,  [BX]
INC BX
JMP ?00

?01: 
INC AX
MOV DX ,  [BX]
INC BX
JMP ?00

?02:
</code></pre> <h3 id="address-of-the-second-maximum">Address of the second maximum</h3> <p>The CX register contains a value - the number of elements of the sequence located starting from the address BX.</p> <p>In the case of an empty sequence, the answer is 0</p> <p>If there is no second maximum, the answer is 0.</p> <p>Example: 1 2 3 2 3 1 ⇒ AX=5.</p> <pre><code class="language-assembly">MOV AX ,  0
MOV [01F8] , 0			; A null address is needed for data transit in this task, and a random address is chosen here, but this is not a good method.
MOV DX ,  [BX]
ADD CX ,  2

?00: 
DEC CX
CMP CX ,  0
JZ  ?10

CMP DX ,  [BX]
JZ  ?01
JC  ?03
INC BX
JMP ?00

?01: 
INC [01F8]
CMP [01F8] ,  2
JZ  ?02
INC BX
JMP ?00


?02: 
MOV AX ,  BX
JMP ?00

?03: 
MOV DX ,  [BX]
MOV [01F8] ,  1
INC BX
JMP ?00

?10: 
</code></pre> <h3 id="number-of-local-maxima-of-the-sequence">Number of local maxima of the sequence</h3> <p>Write a program, after the execution of which, the register AX will contain the number of local maxima of the sequence.</p> <p>The CX register contains a value - the number of elements of the sequence located starting from the address BX.</p> <p>In the case of an empty sequence, the answer is 0.</p> <p>An element of a non-empty sequence is called a local maximum if it has no neighbor greater than itself. For example, a sequence of one element has one local maximum. The sequence 4, 4, 2, 3, 0 has three local maxima: the first, second, and penultimate elements.</p> <pre><code class="language-assembly">; In order to prevent the data outside the specified array will affect the data at both ends, the first judgement CX is not 0, 
; then it is a separate judgement of whether the data at both ends are satisfied, and then it is a judgement of whether the data in the middle is satisfied, 
; the trap is that if the target data of the right side of the data is greater than it, jump out of the body of the program, at this time, BX (which can be taken as a positional pointer) is still parked in the previous one, and we would like to carry out the judgemental force of the next data, so we should update the BX in time.

MOV AX , 0
CMP CX , 0
JZ  ?00

MOV DX ,  [BX]
INC BX
CMP DX ,  [BX]
JC  ?01
INC AX

?01: 
DEC BX
ADD BX ,  CX
DEC BX

MOV DX ,  [BX]
DEC BX
CMP DX ,  [BX]
JC  ?02
INC AX

?02: 

SUB CX ,  2
JZ ?00

?04: 
MOV DX ,  [BX]
INC BX
CMP DX ,  [BX]
JC  ?03
SUB BX , 2
CMP DX ,  [BX]
JC  ?05
INC AX
JMP ?05

?03: 
SUB BX,2
JMP ?05

?05:
SUB CX ,  1
JNZ ?04

?00: 
</code></pre> <h3 id="the-lengths-of-the-sides-form-a-parallelogram">The lengths of the sides form a parallelogram</h3> <p>The array contains the lengths of the sides of the parallelogram as it is traversed clockwise.</p> <p>Write a program that puts 1 in register AX if the elements of the array (lengths of sides) of size CX, starting at address BX, form a parallelogram, and zero otherwise.</p> <p>In case of error data (CX≠4) the answer is 0.</p> <pre><code class="language-assembly">MOV AX , 0
CMP CX ,  4
JNZ  ?00

MOV DX ,  [BX]
ADD BX ,  2
CMP [BX] ,  DX
JNZ ?00

ADD BX , 1
MOV DX ,  [BX]
SUB BX , 2
CMP [BX] ,  DX
JNZ ?00

MOV AX , 1

?00: 
</code></pre> <h2 id="lecture-04">Lecture 04</h2> <h3 id="the-subsequence">The subsequence</h3> <p>In memory at address 0, there is a value - the number of elements of the sequence located starting from address 1.</p> <p>Write a program that leaves the AX register the number of occurrences of the subsequence “1, 2, 3, 1”.</p> <p>In the case of an empty sequence, the answer is 0</p> <p>Example: 7 1 2 3 1 2 3 1 ⇒ AX=2.</p> <blockquote> <p>It is not emphasised here that “1, 2, 3, 1, 2, 3” should be judged as 2 subsequences.</p> </blockquote> <pre><code class="language-assembly">MOV AX ,  0
MOV BX ,  0
CMP [BX] ,  4
JC  ?00

?01: 
MOV CX ,  [0]
INC CX
CMP BX ,  CX
JZ  ?00
INC BX

CMP [BX] , 1
JZ  ?02
JMP ?01

?02: 
INC BX
CMP [BX] , 2
JZ  ?03
JMP ?01

?03: 
INC BX
CMP [BX] , 3
JZ  ?04
JMP ?01

?04: 
INC BX
CMP [BX] ,  1
JZ  ?05
JMP ?01

?05: 
INC AX
DEC BX ;The last number is 1 and the counter BX has to go backwards by one, in order to check if this 1 might be the beginning of a subsequence.
JMP ?01

?00: 
</code></pre> <h3 id="even-odd">Even-odd</h3> <p>In memory at address 0, there is a value - the number of elements of an array of natural numbers (and zero also), located starting from address 1.</p> <p>Let’s call a “strange ascent” the case when there are either even or odd numbers nearby, or the number on the left is odd and the number on the right is even.</p> <p>Write a program that sorts an array in “strange ascending” order.</p> <p>Example: 4 3 2 1 2 2 1 ⇒ 3 1 1 4 2 2 2</p> <p>Remark: Do not change order inside the equivalent class. Wrong answer: 3 1 1 2 4 2 2.</p> <blockquote> <p>The key to this task is to filter out the odd and even numbers without changing the order in which they are each arranged, and then, arrange the odd numbers first and then the even numbers. Note that the RCR approach is used when determining whether the data in memory is odd or even, but you can’t operate directly on that data because it will affect the data in the memory before and after.</p> </blockquote> <pre><code class="language-assembly">CMP [0] ,  0
JZ  ?00
MOV BX ,  0


?02: 
CMP BX ,  [0]
JZ  ?03
INC BX

CLC
MOV DX , [BX]
RCR DX
JC  ?01
JMP ?02

?01: 
PUSH [BX]
JMP ?02

?03: 
MOV BX ,  0

?04: 
CMP BX ,  [0]
JZ  ?06
INC BX

CLC
MOV DX , [BX]
RCR DX
JNC ?05
JMP ?04

?05: 
PUSH [BX]
JMP ?04

?06: 
MOV BX ,  [0]

?07: 
CMP BX ,  0
JZ  ?00
POP [BX]
DEC BX
JMP ?07
  
?00: 
</code></pre> <h3 id="adding-two-long-numbers">Adding two long numbers</h3> <p>Write a program that implements the operation of adding two very long numbers.</p> <p>Integers in the range 0 to \(2^{1024}-1\) are represented as 𝑁 ≤ 64 consecutive words of memory each.</p> <p>Register AX is the address of the first least significant word of the first number, BX=𝑁 is the length of the number.</p> <p>The numbers are in order, so the address of the first digit of the second number is AX+BX. The result must be in the first number.</p> <blockquote> <p>This task pays special attention to the progression, whether there are two numbers produced by adding them together or by the progression of the previous sum.</p> </blockquote> <pre><code class="language-assembly">MOV DX ,  0
MOV CX ,  BX

?00: 
CMP AX ,  CX
JZ  ?03
CLC
ADD [AX] , [BX]
JC  ?01
CLC
ADD [AX] ,  DX
JC  ?02
MOV DX ,  0

INC AX
INC BX
JMP ?00

?01: 
ADD [AX] ,  DX
INC AX
MOV DX , 1
INC BX
JMP ?00

?02: 
INC AX
MOV DX ,  1
INC BX
JMP ?00

?03: 
</code></pre> <h3 id="multiplying-a-number-by-2">Multiplying a number by 2</h3> <p>Write a program that implements the operation of multiplying the first of very long number number by 2.</p> <p>Integers in the range 0 to \(2^{1024}-1\) are represented as 𝑁 ≤ 64 consecutive words of memory each.</p> <p>Register AX is the address of the first least significant word of the first number, BX=𝑁 is the length of the number.</p> <p>The result must be in the first number.</p> <pre><code class="language-assembly">MOV AX ,  0
MOV DX ,  0

?00: 
CMP AX ,  BX
JZ  ?02
CLC
ADD [AX] , [AX]
JC  ?01
ADD [AX] ,  DX
MOV DX ,  0
INC AX
JMP ?00

?01: 
ADD [AX] ,  DX
INC AX
MOV DX ,  1
JMP ?00

?02: 
</code></pre> <h3 id="dividing-a-number-by-2">Dividing a number by 2</h3> <p>Write a program that implements the operation of dividing the first of very long number number by 2.</p> <p>Integers in the range 0 to \(2^{1024}-1\) are represented as 𝑁 ≤ 64 consecutive words of memory each.</p> <p>Register AX is the address of the first least significant word of the first number, BX=𝑁 is the length of the number.</p> <p>The result must be in the first number.</p> <blockquote> <p>The pitfall of this task is that it is possible to use successive RCRs to process the data in order from high to low, but it will destroy the contents of the C flag when determining whether the loop needs to end, so it needs to be specially documented.</p> </blockquote> <pre><code class="language-assembly">CLC

?00: 
RCR [BX]
JC  ?01
CMP BX ,  0
JZ  ?10
DEC BX
JMP ?00

?01: 
CMP BX ,  0
JZ  ?10
DEC BX
CMP BX ,  FFFF
JMP ?00

?10: 
</code></pre> <h2 id="lecture-05">Lecture 05</h2> <h3 id="padovan-problem-by-c">Padovan problem by C</h3> <p>A sequence of integers is read from input using the input.txt file.</p> <p>Answer (0-no, 1-yes) output to output.txt file</p> <p>In the case of an empty sequence, an empty file must be created.</p> \[a_0=1, a_1=1, a_2=1, an=a_{n-2}+a_{n-3}\] <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">recurrent</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a0</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fin</span><span class="p">,</span> <span class="o">*</span><span class="n">fout</span><span class="p">;</span>
    <span class="n">fin</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="n">fout</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"output.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">a0</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">((</span><span class="n">fin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fscanf</span><span class="p">(</span><span class="n">fin</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fout</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">recurrent</span><span class="p">(</span><span class="n">fin</span><span class="p">,</span> <span class="n">a0</span><span class="p">));</span> 
    <span class="p">}</span>
    
    <span class="n">fclose</span><span class="p">(</span><span class="n">fin</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fout</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">recurrent</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a0</span><span class="p">)</span>
<span class="p">{</span>   
 
<span class="p">}</span>
</code></pre></div></div> <h3 id="copy-the-sequence">Copy the sequence</h3> <p>A sequence of integers in the input stream.</p> <p>For reading, the <em>inputInt</em> function is used - returning the read number in the EAX register and the Z=1 flag, in case of reading the end of the file.</p> <p>We need to copy the sequence from the input stream to the output stream.</p> <p>Functions are used for output.</p> <p><em>printiInt</em> - prints the integer contained in the EAX register,</p> <p><em>printiEndl</em> - go to another line,</p> <p>You can also use the <em>printiHex</em> function - prints the hexadecimal representation of the CL register.</p> <p>All output functions store the values of all registers except the flag registers.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex  ; Declare external functions that are used for I/O
%include 'conio.h'                             ; Include console input/output header

section .text                                  ; Begin the text (code) section of the assembly file
global _start                                  ; Declare the _start label as global so it's visible to the linker

_start:                                        ; The entry point of the program

call inputInt                                  ; Call inputInt to read an integer from standard input
mov rdi,-1                                     ; Preset rdi with -1, which is potentially used for error signaling
jz .exit                                       ; If zero flag is set (inputInt read EOF), jump to .exit
call printInt                                  ; Call printInt to print the integer in EAX
call printEndl                                 ; Call printEndl to print a newline

.repit:                                        ; Label for the beginning of the loop
call inputInt                                  ; Call inputInt to read the next integer from standard input
jz .exit0                                      ; If zero flag is set (inputInt read EOF), jump to .exit0
call printInt                                  ; Call printInt to print the integer in EAX
call printEndl                                 ; Call printEndl to print a newline
jmp .repit                                     ; Jump back to the start of the loop

.exit0:                                        ; Label for exiting after printing all integers
xor rdi, rdi                                   ; Clear rdi register (sets the value to 0) to signal successful end
.exit:                                         
mov rax, 60                                    ; Load the sys_exit system call number into rax
syscall                                        ; Make the system call to exit the program
</code></pre> <h3 id="maximum-of-the-sequence">Maximum of the sequence</h3> <p>A sequence of integers in the input stream.</p> <p>For reading, the <em>inputInt</em> function is used - returning the read number in the EAX register and the Z=1 flag, in case of reading the end of the file.</p> <p>We need to find the maximum of the sequence and print the answer to the output stream.</p> <p>Functions are used for output.</p> <p><em>printiInt</em> - prints the integer contained in the EAX register,</p> <p><em>printiEndl</em> - go to another line,</p> <p>You can also use the <em>printiHex</em> function - prints the hexadecimal representation of the CL register.</p> <p>All output functions store the values of all registers except the flag registers.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt         
    jz .emptySequence     

    mov ebx, eax          

.findMaxLoop:
    call inputInt         
    jz .printMax          

    cmp eax, ebx          
    jle .findMaxLoop      
    mov ebx, eax          
    jmp .findMaxLoop      

.printMax:
    mov eax, ebx          
    call printInt         
    call printEndl        
    jmp .exit             

.emptySequence:
    mov rax, 60
    mov edi, 255
    syscall

.exit:
    mov eax, 60           
    xor edi, edi          
    syscall               
</code></pre> <h3 id="padovan-problem">Padovan problem</h3> <p>A sequence of integers in the input stream.</p> <p>Answer (0-no, 1-yes) to the output stream, is it a Padovan sequence?</p> <p>In the case of an empty sequence, the program exit code is -1.</p> \[a_0=1, a_1=1, a_2=1, an=a_{n-2}+a_{n-3}\] <blockquote> <p>One note of caution here, rax must be assigned the value 60 on return.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt
    jz .errexit
    cmp eax, 1
    jnz .notpad
    call inputInt
    jz .ispad
    cmp eax, 1
    jnz .notpad
    call inputInt
    jz .ispad
    cmp eax, 1
    jnz .notpad
    
    
    mov ebx, 1
    mov ecx, 1
    mov edx, 1

.lp:
    call inputInt
    jz .ispad
    
    add ebx, ecx
    mov r8d, ebx
    mov ebx, ecx
    mov ecx, edx
    mov edx, r8d
    cmp eax, edx
    jnz .notpad
    jmp .lp

.ispad:
    mov eax, 1
    xor rdi, rdi
    call printInt
    jmp .exit
    
.notpad:
    mov eax, 0
    xor rdi, rdi
    call printInt
    jmp .exit
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.exit:
    mov rax, 60
    syscall
</code></pre> <h3 id="missing-number">Missing number</h3> <p>The sequence contains integers from 1 to N in arbitrary order, but one of the numbers is missing (the rest occur exactly once). N is not known in advance. Find the missing number.</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>IIn the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>Since we don’t know how many numbers there are and the order of the series, then we can only determine the number of numbers, then find the series sum if there are no missing numbers, and then subtract the actual series sum to get what the missing numbers are.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt
    jz .errexit
    
    mov ebx, 1
    mov ecx, eax
    mov edx, 1

.lp:
    call inputInt
    jz .lpend
    add ebx, 1
    add edx, ebx
    add ecx, eax
    jmp .lp

.lpend:
    add ebx, 1
    add edx, ebx
    sub edx, ecx
    mov eax, edx
    call printInt
    jmp .exit
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.exit:
    xor rdi, rdi
    mov rax, 60
    syscall
</code></pre> <h3 id="number---loner">Number - loner</h3> <p>The sequence contains integers from 1 to N. All numbers except one are written twice in random order, one of the numbers is written once. N is not known in advance. Find a number that occurs once.</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>This task involves multiplication and division, but of course you can add and subtract instead, but it’s too tedious.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt
    jz .errexit
    
    mov ebx, 1
    mov ecx, eax
    
.lp:
    call inputInt
    jz .endlp
    add ebx, 1
    add ecx, eax
    jmp .lp

.endlp:
    mov eax, ebx
    mov eax, ecx
    add ebx, 1
    mov eax, ebx
    mov ebx, 2
    div ebx
    mov ebx, eax
    add eax, 1
    mul ebx
    sub eax, ecx
    call printInt
    jmp .exit
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.exit:
    xor rdi, rdi 
    mov rax, 60
    syscall
</code></pre> <h3 id="find-the-number">Find the number</h3> <p>The sequence contains integers, more than half of which are equal to the same number X.</p> <p>It is necessary to find this number X. It is guaranteed that such a number exists.</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>This task requires the use of the “Moore’s Vote Algorithm”, the catch being that a number is read before it is judged to be empty, so the initial state of the counter is 1 and not 0.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt
    jz .errexit
    
    mov ecx, eax
    mov edx, 1
    
.lp:
    call inputInt
    jz .exit
    cmp edx, 0
    jz .new
    cmp ecx, eax
    jz .count
    sub edx, 1
    jmp .lp
    
.new:
    mov ecx, eax
    mov edx, 1
    jmp .lp
    
.count:
    add edx, 1
    jmp .lp

.errexit:
    mov rdi, -1
    mov rax, 60
    syscall
    
.exit:
    xor rdi, rdi
    mov eax, ecx
    call printInt
    mov rax, 60
    syscall
</code></pre> <h3 id="second-highest-silver">Second highest (silver)</h3> <p>The second largest element is the one that becomes the largest element in the sequence after all elements with the highest value have been removed from it.</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>Negative numbers will appear in the program verification of the task, so the compare operation instruction should only be used with signed comparisons.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:
    
    call inputInt
    jz .errexit
    mov ebx, eax
    call inputInt
    jz .emptyexit
    mov ecx, eax
    cmp ecx, ebx
    jl .lp
    mov eax, ebx
    mov ebx, ecx
    mov ecx, eax
    
.lp:
    call inputInt
    jz .ifequ
    cmp eax, ebx
    jz .lp
    jge .s1
    cmp eax, ecx
    jz .lp
    jge .s2
    jmp .lp
    
.s1:
    mov ecx, ebx
    mov ebx, eax
    jmp .lp
    
.s2:
    mov ecx, eax
    jmp .lp
    
.ifequ:
    cmp ebx, ecx
    jz .emptyexit
    jmp .exit
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.emptyexit:
    mov rdi, 0
    mov rax, 60
    syscall

.exit:
    mov rdi, 0
    mov eax, ecx
    call printInt
    mov rax, 60
    syscall
</code></pre> <h3 id="the-sum-of-pairwise-products">The sum of pairwise products</h3> <p>Find the sum of all pairwise products of a sequence</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>Assuming that we have only one chance to read the array and we don’t want to request dynamic memory, the problem must be solved in \(O(n)\), and that requires a formula:</p> \[SUM = \frac{1}{2}((\sum_{i=1}^na_i)^2-\sum_{i=1}^na_i^2)\] </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    xor ebx, ebx
    xor ecx, ecx
    
    call inputInt
    jz .errexit
    
    add ebx, eax
    mul eax
    add ecx, eax
    
    call inputInt
    jz .errexit
    
    add ebx, eax
    mul eax
    add ecx, eax
    
.lp:
    call inputInt
    jz .endlp
    add ebx, eax
    mul eax
    add ecx, eax
    jmp .lp
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.endlp:
    mov eax, ebx
    mul eax
    sub eax, ecx
    clc
    rcr eax, 1
    call printInt
    
.exit:
    mov rdi, 0
    mov rax, 60
    syscall
</code></pre> <h3 id="copy-array">Copy array</h3> <p>An array of integers is located in the file input stream. It is required to create an array of N&lt;100 elements and read the array.</p> <p>You need to copy all array to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <pre><code class="language-assembly">; External function declarations
extern printEndl, printInt, inputInt, printHex
%include 'conio.h'  ; Include the conio.h library for console input-output support

section .bss
A:resd 100  ; Allocate space for an array, defining array A to hold 100 integers

section .text
global _start  ; Declare _start as globally visible so that the linker can find the entry point of the program

_start:  ; Start of the program

mov ecx,0   ; Initialize counter ecx to 0, for array indexing
mov ebx,A   ; Assign the address of array A to ebx, for subsequent read/write operations

.readA:  ; Label for reading input
call inputInt  ; Call inputInt to read an integer from standard input into eax
jz .eofA  ; If the input is 0, jump to .eofA to handle end-of-file condition
mov [A+ecx*4],eax;  ; Store the read integer at the corresponding position in array A
inc ecx  ; Increase the value of ecx, moving to the next position in the array
jmp .readA  ; Jump back to .readA to continue reading the next integer

.eofA:  ; Handle end-of-input condition
mov rdi,-1  ; Store -1 in rdi, set as error return code
test ecx,ecx  ; Test if ecx is 0 (i.e., if the array is empty)
jz .exit  ; If the array is empty, jump directly to .exit to exit the program

mov ebx,A  ; Reset ebx to the starting address of array A
.writeA:  ; Start writing label
mov eax,[ebx]  ; Read the current element from array A into eax
call printInt  ; Call printInt to print the value of eax
call printEndl  ; Print a newline
add ebx,4  ; Move ebx to the next element in the array
loop .writeA  ; Use ecx as a counter to loop through .writeA using the loop instruction

xor rdi, rdi ; Clear rdi, set as success return code

.exit:  ; Exit label
mov rax, 60  ; Set rax to 60, corresponding to the sys_exit system call number
syscall  ; Perform a system call to exit the program
</code></pre> <h3 id="sort-array">Sort array</h3> <p>An array of integers is located in the file input stream. It is required to create an array of N&lt;100 elements and read the array.</p> <p>You need to sort an array of integers in ascending order to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <pre><code class="language-assembly">; External function declarations
extern printEndl, printInt, inputInt, printHex
%include 'conio.h'  ; Includes the conio.h library for console input-output support

section .bss
A:resd 100  ; Reserves space for an array of 100 integers

section .text
global _start  ; Declares _start as globally visible, marking the entry point of the program

_start:  ; Program start

mov ecx, 0  ; Clears the ecx register, to be used as the array index
mov ebx, A  ; Loads the address of array A into ebx for array operations
.readA:  ; Start of the loop to read the array
call inputInt  ; Calls inputInt function to read an integer from standard input
jz .eofA  ; If input is zero, jump to .eofA to handle end of input
mov [A+ecx*4], eax;  ; Stores the input integer at the current index position in the array
inc ecx  ; Increments index, preparing to read the next value
jmp .readA  ; Jumps back to the start of the read loop

.eofA:
mov rdi, -1  ; Sets return error code to -1
test ecx, ecx  ; Tests if ecx is zero, i.e., if the array is empty
jz .exit  ; If the array is empty, jumps to exit

mov ebx, A  ; Resets ebx to point to the start of the array
call _sort  ; Calls the _sort function to sort the array

mov ebx, A  ; Again sets ebx to point to the start of the array
.writeA:  ; Starts the loop to write the array
mov eax, [ebx]  ; Reads the current element from the array
call printInt  ; Calls printInt to print the current integer
call printEndl  ; Calls printEndl to print a newline
add ebx, 4  ; Moves to the next element in the array
loop .writeA  ; Continues to output using loop instruction until ecx decrements to zero

xor rdi, rdi ; Clears the rdi register, sets the success return code

.exit:
mov rax, 60  ; Sets rax to 60, corresponding to the sys_exit system call
syscall  ; Performs a system call to exit the program

_sort:
pushq  ; Saves register state
dec ecx  ; Decrement array length by one, preparing for sorting
.?loop1:  ; Label for the first loop
push rcx
push rbx

.?loop2:  ; Label for the second loop

mov eax, [ebx]  ; Takes the current element from the array
cmp eax, [ebx+4]  ; Compares it with the next element
jle .?1  ; If the current element is less than or equal to the next, skip swapping
xchg eax, [ebx+4]  ; Swaps the two elements
mov [ebx], eax

.?1:
add bx, 4  ; Moves to the next element
loop .?loop2  ; Continues the inner loop

pop rbx
pop rcx
loop .?loop1  ; Continues the outer loop
popq  ; Restores register state
ret  ; Returns to the calling point
</code></pre> <h3 id="even-strange-odd">Even strange (Odd)</h3> <p>An array of integers is located in the file input stream. It is required to create an array of N&lt;100 elements and read the array.</p> <p>You need to output:</p> <p>- the maximum even element, if the number of even elements is not less than the number of odd ones;</p> <p>- the maximum odd element, if the number of odd elements is greater than even ones.</p> <p>For example, for an array of six elements equal to 4, 6, 12, 17, 3, 8, respectively, the answer will be 12 - the largest even number, since there are more even numbers in this array.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>The -2147483648 set here is the smallest negative number that can be stored in a 32-bit register, i.e. it ranges from -2147483648 to 2147483647.</p> <p>The test instruction is essentially a logical and arithmetic instruction, but it does not save the result of the operation; if the result of the operation is 0, then ZF = 1, for example:</p> <pre><code class="language-assembly">test al, 1
jz even  ; If the lowest bit of al is 0, then jump to the even tag and al is an even number

test ebx, ebx
jz is_zero  ; If ebx is 0, jump to is_zero tag
</code></pre> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .bss
A:resd 100  ; space for an array

section .text
global _start

_start:

    mov ecx, 0      
    mov ebx, A      
    
    mov edi, -2147483648  
    mov esi, -2147483648  
    mov edx, 0            
    mov ebp, 0            

.read_loop:
    call inputInt        
    test eax, eax        
    jz .finalize          
    mov [ebx+ecx*4], eax 
    inc ecx              

    
    test eax, 1          
    jnz .odd_number 
    
.even_number:
    inc edx              
    cmp eax, esi         
    jle .skip_even        
    mov esi, eax         
    jmp .skip_odd
    
.odd_number:
    inc ebp              
    cmp eax, edi         
    jle .skip_odd        
    mov edi, eax  
    
.skip_odd:
.skip_even:
    jmp .read_loop      

.finalize:    
    test ecx, ecx
    jz .empty_array      

    
    cmp ebp, edx         
    jg .output_odd    
    
.output_even:
    mov eax, esi        
    jmp .output
    
.output_odd:
    mov eax, edi      
    
.output:
    call printInt       
    call printEndl      
    xor rdi, rdi        
    jmp .exit_program

.empty_array:
    mov rdi, -1          

.exit_program:
    mov rax, 60          
    syscall              
</code></pre>]]></content><author><name></name></author><category term="Tasks"/><category term="Math"/><category term="Code"/><summary type="html"><![CDATA[all Task of Assembly Language]]></summary></entry><entry><title type="html">Some points of Assembly Language 2024</title><link href="https://sirenexcelsior.github.io/blog/2024/as-point/" rel="alternate" type="text/html" title="Some points of Assembly Language 2024"/><published>2024-03-30T00:00:00+00:00</published><updated>2024-03-30T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/as-point</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/as-point/"><![CDATA[<p>This is a site for some points about the course <a href="https://scs.math.msu.ru/node/4281">Assembly Language</a>, Spring 2024, taught by Леонов Александр Георгиевич, on the online course platform <a href="https://mirera.ru/user/groups/65cb80e98cd5ad641f4efb8b">mirera.ru</a>.</p> <h2 id="16-bit-computing">16-bit computing</h2> <h3 id="true-form-ones-complement-and-twos-complement">True Form, Ones’ Complement and Two’s Complement</h3> <h4 id="true-form">True Form</h4> <p>Sign-magnitude is the most intuitive representation method. In sign-magnitude, the most significant bit (often called the sign bit) is used to represent the sign of the number, where <code class="language-plaintext highlighter-rouge">0</code> denotes a positive value and <code class="language-plaintext highlighter-rouge">1</code> denotes a negative value. The remaining bits represent the magnitude of the number.</p> <p>For example, if we represent a decimal number using 8-bit binary:</p> <ul> <li><code class="language-plaintext highlighter-rouge">+9</code> in sign-magnitude is <code class="language-plaintext highlighter-rouge">00001001</code> (the first bit is the sign bit, <code class="language-plaintext highlighter-rouge">0</code> for positive, followed by the 7-bit binary representation of the number 9).</li> <li><code class="language-plaintext highlighter-rouge">-9</code> in sign-magnitude is <code class="language-plaintext highlighter-rouge">10001001</code> (the first bit is the sign bit, <code class="language-plaintext highlighter-rouge">1</code> for negative, the next 7 bits still represent the number 9).</li> </ul> <p>The range of integers that can be represented:</p> <ul> <li>The range for positive numbers: <code class="language-plaintext highlighter-rouge">00000001</code> to <code class="language-plaintext highlighter-rouge">01111111</code>, which corresponds to decimal <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">127</code>.</li> <li>The range for negative numbers: <code class="language-plaintext highlighter-rouge">10000001</code> to <code class="language-plaintext highlighter-rouge">11111111</code>, which corresponds to decimal <code class="language-plaintext highlighter-rouge">-1</code> to <code class="language-plaintext highlighter-rouge">-127</code>.</li> <li>Positive zero: <code class="language-plaintext highlighter-rouge">00000000</code>, which corresponds to decimal <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>Negative zero: <code class="language-plaintext highlighter-rouge">10000000</code>, which is considered as <code class="language-plaintext highlighter-rouge">-0</code> in sign-magnitude representation, but in reality, <code class="language-plaintext highlighter-rouge">-0</code> is equivalent to <code class="language-plaintext highlighter-rouge">+0</code> in value.</li> </ul> <p>Thus, using sign-magnitude, an 8-bit register can represent integers in the range of <code class="language-plaintext highlighter-rouge">-127</code> to <code class="language-plaintext highlighter-rouge">+127</code>, plus a <code class="language-plaintext highlighter-rouge">0</code>.</p> <h4 id="ones-complement">Ones’ Complement</h4> <p>Ones’ complement is used for representing negative numbers. For positive numbers, the ones’ complement is the same as the sign-magnitude; for negative numbers, the ones’ complement is obtained by inverting all the bits of the magnitude part of the number.</p> <p>Continuing with the same examples:</p> <ul> <li><code class="language-plaintext highlighter-rouge">+9</code> in ones’ complement remains the same as its sign-magnitude, which is <code class="language-plaintext highlighter-rouge">00001001</code>.</li> <li><code class="language-plaintext highlighter-rouge">-9</code> in ones’ complement is <code class="language-plaintext highlighter-rouge">11110110</code> (the sign bit remains <code class="language-plaintext highlighter-rouge">1</code>, while the rest of the bits are inverted).</li> </ul> <p>The range of integers that can be represented:</p> <ul> <li>The range for positive numbers: Same as sign-magnitude, from <code class="language-plaintext highlighter-rouge">00000001</code> to <code class="language-plaintext highlighter-rouge">01111111</code>, decimal <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">127</code>.</li> <li>The range for negative numbers: <code class="language-plaintext highlighter-rouge">11111110</code> to <code class="language-plaintext highlighter-rouge">10000000</code>, decimal <code class="language-plaintext highlighter-rouge">-1</code> to <code class="language-plaintext highlighter-rouge">-127</code> (note that negative numbers are the inversion of their magnitude).</li> <li>Positive zero: <code class="language-plaintext highlighter-rouge">00000000</code>, decimal <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>Negative zero: <code class="language-plaintext highlighter-rouge">11111111</code>, which is the representation of <code class="language-plaintext highlighter-rouge">-0</code> in ones’ complement.</li> </ul> <p>The integer range for ones’ complement representation is also <code class="language-plaintext highlighter-rouge">-127</code> to <code class="language-plaintext highlighter-rouge">+127</code>, but there are two representations for zero.</p> <h4 id="twos-complement">Two’s Complement</h4> <p>Two’s complement is also used to represent negative numbers and is the standard in modern computer systems. For positive numbers, the two’s complement is the same as the sign-magnitude; for negative numbers, the two’s complement is found by adding one to the ones’ complement of the number’s magnitude.</p> <p>Continuing with the same examples:</p> <ul> <li><code class="language-plaintext highlighter-rouge">+9</code> in two’s complement is the same as its sign-magnitude, <code class="language-plaintext highlighter-rouge">00001001</code>.</li> <li><code class="language-plaintext highlighter-rouge">-9</code> in two’s complement is the ones’ complement <code class="language-plaintext highlighter-rouge">11110110</code> plus one, resulting in <code class="language-plaintext highlighter-rouge">11110111</code>.</li> </ul> <p>The range of integers that can be represented:</p> <ul> <li>The range for positive numbers: Same as sign-magnitude and ones’ complement, from <code class="language-plaintext highlighter-rouge">00000001</code> to <code class="language-plaintext highlighter-rouge">01111111</code>, decimal <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">127</code>.</li> <li>The range for negative numbers: <code class="language-plaintext highlighter-rouge">11111111</code> to <code class="language-plaintext highlighter-rouge">10000000</code>, decimal <code class="language-plaintext highlighter-rouge">-1</code> to <code class="language-plaintext highlighter-rouge">-128</code>. Note that in two’s complement, <code class="language-plaintext highlighter-rouge">10000000</code> represents <code class="language-plaintext highlighter-rouge">-128</code>.</li> <li>Zero: <code class="language-plaintext highlighter-rouge">00000000</code>, in two’s complement, there is only one representation of zero, decimal <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <h3 id="common-arithmetic-instructions">Common Arithmetic Instructions</h3> <table> <thead> <tr> <th>Command</th> <th>Action</th> <th>Example</th> <th>Flag Z</th> <th>Flag C</th> </tr> </thead> <tbody> <tr> <td>DEC d</td> <td>d = d-1</td> <td>DEC AX</td> <td>✓</td> <td>-</td> </tr> <tr> <td>INC d</td> <td>d = d+1</td> <td>INC [BX]</td> <td>✓</td> <td>-</td> </tr> <tr> <td>ADD d,s</td> <td>d = d+s</td> <td>ADD AX, 20</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>SUB d,s</td> <td>d = d-s</td> <td>SUB CX, [1]</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>MOV d,s</td> <td>d = s</td> <td>MOV AX, [100]</td> <td>-</td> <td>-</td> </tr> <tr> <td>ADC d,s</td> <td>d = d+s+C</td> <td>ADC [AX], 20</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>SBB d,s</td> <td>d = d-s-C</td> <td>SBB [02], 1</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>CMP d,s</td> <td>d - s</td> <td>CMP AX, [1]</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>POP d</td> <td>d = [SP–]</td> <td>POP BX</td> <td>-</td> <td>-</td> </tr> <tr> <td>PUSH d</td> <td>[++SP] = d</td> <td>PUSH [102]</td> <td>-</td> <td>-</td> </tr> <tr> <td>AND d,s</td> <td>d = d &amp; s</td> <td>AND AX, [1]</td> <td>✓</td> <td>0</td> </tr> <tr> <td>OR d,s</td> <td>d = d | s</td> <td>OR [BX], [AX]</td> <td>✓</td> <td>0</td> </tr> <tr> <td>NEG d</td> <td>d = -d</td> <td>NEG [AX]</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>RCL d</td> <td>C -&gt; \(d_0\),d = d*2,\(d_{15}\) -&gt; C</td> <td>RCL BX</td> <td>-</td> <td>✓</td> </tr> <tr> <td>RCR d</td> <td>C -&gt; \(d_{15}\),d=d/2,\(d_0\)-&gt; C</td> <td>RCR [2]</td> <td>-</td> <td>✓</td> </tr> </tbody> </table> <h4 id="adc-add-with-carry">ADC (Add with Carry)</h4> <p>The <code class="language-plaintext highlighter-rouge">ADC</code> instruction stands for “Add with Carry.” It adds the source operand (s), the destination operand (d), and the carry flag (C) together.</p> <p><strong>Use cases</strong>:</p> <ul> <li><strong>Multi-byte addition</strong>: <code class="language-plaintext highlighter-rouge">ADC</code> is used when performing addition operations that exceed the capacity of a single register. For instance, in a 32-bit system, if we need to add two 64-bit numbers, we would need to divide this operation into two parts, each 32 bits, held in two separate registers. First, we add the lower 32 bits, and then use <code class="language-plaintext highlighter-rouge">ADC</code> to add the upper 32 bits, which automatically includes the carry from the lower addition if there is one.</li> <li><strong>Extended arithmetic operations</strong>: During extended arithmetic operations, such as those found in cryptography or digital signature algorithms, operands can be very large and not fit within a single register. <code class="language-plaintext highlighter-rouge">ADC</code> is useful here to handle each segment of the operand and include carryovers from previous additions.</li> </ul> <h4 id="sbb-subtract-with-borrow">SBB (Subtract with Borrow)</h4> <p>The <code class="language-plaintext highlighter-rouge">SBB</code> instruction stands for “Subtract with Borrow.” It subtracts the source operand (s) from the destination operand (d) and then also subtracts the carry flag (C), which in the context of subtraction is treated as a borrow.</p> <p><strong>Use cases</strong>:</p> <ul> <li><strong>Multi-byte subtraction</strong>: Similar to <code class="language-plaintext highlighter-rouge">ADC</code>, <code class="language-plaintext highlighter-rouge">SBB</code> is used for subtraction that involves numbers larger than what a single register can hold. After subtracting the lower part of the operands, <code class="language-plaintext highlighter-rouge">SBB</code> helps to subtract the higher part along with any borrow that resulted from the lower subtraction.</li> <li><strong>Extended arithmetic operations</strong>: For large numerical operations that require precise subtraction over multiple data words, <code class="language-plaintext highlighter-rouge">SBB</code> can sequentially subtract along with borrows, ensuring that the extended precision is maintained across the entire operation.</li> </ul> <h4 id="large-number-addition-and-large-number-subtraction">Large Number Addition and Large Number Subtraction</h4> <p>To perform large number arithmetic with numbers stored across two registers, you would perform addition or subtraction by handling the carry or borrow flags appropriately.</p> <pre><code class="language-assembly">; Assuming AX:BX contains the first large number (higher part in AX, lower part in BX)
; Assuming CX:DX contains the second large number (higher part in CX, lower part in DX)
; The result will be stored in AX:BX

; First, add the lower parts
ADD BX, DX ; BX = lower part of the first number + lower part of the second number
ADC AX, CX ; AX = higher part of the first number + higher part of the second number + carry

; Assuming AX:BX contains the first large number (higher part in AX, lower part in BX)
; Assuming CX:DX contains the second large number (higher part in CX, lower part in DX)
; The result will be stored in AX:BX

; First, subtract the lower parts
SUB BX, DX ; BX = lower part of the first number - lower part of the second number
SBB AX, CX ; AX = higher part of the first number - higher part of the second number - borrow
</code></pre>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><category term="Code"/><summary type="html"><![CDATA[some points of Assembly Language]]></summary></entry><entry><title type="html">Доп. главы по алгебре - Кольцо</title><link href="https://sirenexcelsior.github.io/blog/2024/algebraic/" rel="alternate" type="text/html" title="Доп. главы по алгебре - Кольцо"/><published>2024-03-30T00:00:00+00:00</published><updated>2024-03-30T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/algebraic</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/algebraic/"><![CDATA[<h2 id="кольцо">Кольцо</h2> <p>Кольцо – это множество \(A\) с двумя бинарными операциями (сложением и умножением), для которых выполнены следующие аксиомы:</p> <ol> <li> <p>относительно сложения, \(A\) – абелева группа,</p> </li> <li> <p>умножение дистрибутивно:</p> \[𝑎 \cdot (𝑏 + 𝑐) = 𝑎 \cdot 𝑏 + 𝑎 \cdot 𝑐\] \[(𝑏 + 𝑐) \cdot 𝑎 = 𝑏 \cdot 𝑎 + 𝑐 \cdot 𝑎\] </li> </ol> <table> <thead> <tr> <th style="text-align: center">+</th> <th style="text-align: center">·</th> <th style="text-align: center">·(+)</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">结合律</td> <td style="text-align: center">结合律</td> <td style="text-align: center">分配律</td> </tr> <tr> <td style="text-align: center">单位元</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> </tr> <tr> <td style="text-align: center">逆元</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> </tr> <tr> <td style="text-align: center">交换律</td> <td style="text-align: center"> </td> <td style="text-align: center"> </td> </tr> </tbody> </table> <blockquote> <p>环结构是在阿贝尔群的基础上，引入了第二种运算操作，一般称之为“乘法”，而原有的第一种运算操作一般称之为“加法”。于是，加法下集合构成一个阿贝尔群，而乘法下集合满足结合律，进而加法在乘法的作用下满足分配律。</p> <p>特别的，满足加法结合律的集合被称为“半群”，满足加法结合律并具备单位元的集合被称为“幺半群”，在此基础上每个元素都存在逆元的幺半群被称为“群”。</p> </blockquote> <h2 id="алгебра">Алгебра</h2> <p>Алгебра над полем \(\mathbb{K}\) – это множество \(A\) с тремя операциями: сложение, умножение, умножение на элементы поля \(\mathbb{K}\) (скаляры), для которых выполнены следующие аксиомы:</p> <ol> <li> <p>относительно сложения и умножения на скаляры, \(A\) – векторное пространство над \(\mathbb{K}\),</p> </li> <li> <p>умножение билинейно, т.е. выполнены свойства:</p> <ol> <li> <p>дистрибутивность</p> \[𝑎 \cdot (𝑏 + 𝑐) = 𝑎 \cdot 𝑏 + 𝑎 \cdot 𝑐\] \[(𝑏 + 𝑐) \cdot 𝑎 = 𝑏 \cdot 𝑎 + 𝑐 \cdot 𝑎\] </li> <li> <p>однородность: \(\forall a,b \in A,\forall \lambda \in \mathbb{K}\).</p> </li> </ol> \[(\lambda \cdot a )\cdot b = a \cdot (\lambda \cdot b)=\lambda \cdot (a \cdot b)\] </li> </ol> <blockquote> <p>当不关注代数结构上的标量域时，剩下的运算操作是符合环结构的定义的，所以说常将代数结构和环结构放在一起讨论定义，如：子环（子代数），环（代数）的同态与直和等等。</p> </blockquote> <h2 id="некоторые-определения-и-свойства-связанные-с-кольцами-алгебраически">Некоторые определения и свойства, связанные с кольцами (алгебраически)</h2> <h3 id="подкольцо">Подкольцо</h3> <p>Подкольцо (подалгбра) - подмножество кольца (алгбры), которые само является кольцом (алгеброй) относитльно тех же операций (ограничения операций).</p> <h3 id="идеалы">Идеалы</h3> <p>Идеал - это подмножество \(I \subset A\), для которого:</p> <ol> <li>\(I\) - подгруппа относительно сложения (для колец), – векторное подпространство (для алгебр).</li> <li>\(A\cdot I\subseteq I\) – левый идеал, \(I\cdot A\subseteq I\) – правый идеал, \(A\cdot I\subseteq I, I\cdot A\subseteq I\) - двусторонние идеалы, аналогом нормальных подгрупп. Обозначение для двустороннего идеала: \(I \lhd A\).</li> </ol> <blockquote> <p>这里的左乘和右乘可以理解成描述环在乘法中的位置，而不是这个子环的位置。由于域上代数也是一种环，所以也符合这些定义。</p> </blockquote> <p>[例子] 整数环\(\mathbb{Z}\)和它的一个子集\(n\mathbb{Z}\)，这个子集表示所有能被整数\(n\)整除的整数的集合，如：\(2\mathbb{Z}=\{\cdots,-4,-2,0,2,4,\cdots\}\)，这里\(2\mathbb{Z}\)就是\(\mathbb{Z}\)的一个双边理想（加法下是一个子群，乘法下符合左右乘的规则）。</p> <h3 id="факторкольцо">Факторкольцо</h3> <p>Пусть \(A\) – кольцо или алгебра, \(I \lhd A\), \(A/I=\{a+I\|a\in A\}\) - факторгруппа по сложению.</p> <p>Операция умножения: \(\forall a,b\in A, (a+I)\cdot (b+I)=a\cdot b +I\), умножение на скаляры (для алгебр): \(\forall \lambda \in \mathbb{K}, \lambda (a+I)=\lambda a+I\).</p> <blockquote> <p>由于理想\(I\)对环\(A\)中的加法和乘法是封闭的，所以\(a\cdot I\)，\(b\cdot I\)，\(I\cdot I\)的结果都是\(I\)。</p> <p>在\(A/I\)中的加法定义为陪集的加法，乘法运算即\(\forall a,b\in A, (a+I)\cdot (b+I)=a\cdot b +I\)，这保证了\(A/I\)在乘法下也是封闭的，代数上会多出一个标量乘法，定义为先将元素\(a\)与\(\lambda\)相乘再加上一个\(I\)形成一个新的陪集。</p> </blockquote>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><category term="Algebra"/><summary type="html"><![CDATA[Дополнительные главы по алгебре]]></summary></entry><entry><title type="html">Философия математики</title><link href="https://sirenexcelsior.github.io/blog/2024/math-philosophy/" rel="alternate" type="text/html" title="Философия математики"/><published>2024-03-01T00:00:00+00:00</published><updated>2024-03-01T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/math-philosophy</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/math-philosophy/"><![CDATA[<h2 id="книжный-список">Книжный список</h2> <table> <thead> <tr> <th>Название книги</th> <th style="text-align: center">Автор</th> <th style="text-align: center">Главы и номера страниц</th> <th style="text-align: center"> </th> </tr> </thead> <tbody> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Давид%20Гильберь.%20О%20бесконечном.%20Гильберт%20избранные%20труды%20том%201.pdf">Гильберт избранные труды том 1. 1930</a></td> <td style="text-align: center">Давид Гильберь</td> <td style="text-align: center">О бесконечном. Начало на стр. 431</td> <td style="text-align: center"> </td> </tr> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Николя%20Бурбаки.%20Архитектура%20математики.pdf">Архитектура математики</a></td> <td style="text-align: center">Николя Бурбаки</td> <td style="text-align: center">-</td> <td style="text-align: center"> </td> </tr> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Г.%20Кантор%2C%20книга%20%22Теория%20множеств%22%2C%201985%2C%20Москва.pdf">Труды по теории множеств, 1985, Москва</a></td> <td style="text-align: center">Георг Кантор</td> <td style="text-align: center">Стр 63-81 статья “Основа общего учения о многообразиях “</td> <td style="text-align: center"> </td> </tr> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Анри%20Пуанкаре%2C%20книга%20в%204х%20томах%20О%20науке.pdf">Книга в 4х томах “О науке”</a></td> <td style="text-align: center">Анри Пуанкаре</td> <td style="text-align: center">параграф “Интуиция и логика в математике”. Начало на стр. 159</td> <td style="text-align: center"> </td> </tr> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Nepostizhimaya_effektivnost_matematiki_v_estestvennykh_naukakh_E_Vigner.pdf">Непостижимая эффективность математики в естественных науках</a></td> <td style="text-align: center">Юджин Вигнер</td> <td style="text-align: center">-/<a href="https://vk.com/@-91031095-nepostizhimaya-effektivnost-matematiki-v-estestvennyh-naukah">Website</a></td> <td style="text-align: center"> </td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><category term="Philosophy"/><summary type="html"><![CDATA[Книжный список]]></summary></entry></feed>