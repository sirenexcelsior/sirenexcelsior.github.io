<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://sirenexcelsior.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sirenexcelsior.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-10-15T12:13:16+00:00</updated><id>https://sirenexcelsior.github.io/feed.xml</id><title type="html">blank</title><subtitle>A SiREN&apos;s HomePage. </subtitle><entry><title type="html">CLIP - Building a Bridge Between Text and Images Using Contrastive Learning</title><link href="https://sirenexcelsior.github.io/blog/2025/CLIP/" rel="alternate" type="text/html" title="CLIP - Building a Bridge Between Text and Images Using Contrastive Learning"/><published>2025-10-14T00:00:00+00:00</published><updated>2025-10-14T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2025/CLIP</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2025/CLIP/"><![CDATA[<p><strong>CLIP (Contrastive Language–Image Pre-training)</strong> is a vision-language contrastive learning model proposed by OpenAI in 2021. It learns visual concepts from 400 million image–text pairs collected from the internet without any manual annotations. The model consists of an image encoder and a text encoder. Through a contrastive learning objective, it brings matching images and texts closer together in the same embedding space while pushing non-matching pairs apart, thereby obtaining general representations capable of understanding semantics across modalities.</p> <p>After training, CLIP can perform <em>zero-shot classification</em>: category labels are converted into natural language descriptions (e.g., “A photo of a dog”) and then compared with image features based on similarity. This allows the model to recognize new tasks or categories without any further training. By using natural language as a supervisory signal, CLIP gains strong generalization and task transfer abilities.</p> <p>CLIP can be considered one of the foundational cornerstones of modern Vision-Language Models (VLMs). It was the first to systematically demonstrate that by unifying visual and linguistic representation spaces through contrastive learning, a model can achieve powerful cross-modal understanding and transfer capabilities without task-specific fine-tuning. This idea directly inspired the design of nearly all subsequent VLMs.</p> <p>Within VLM architectures, CLIP typically serves as the <em>aligner</em> or <em>encoder backbone</em> between vision and language. It provides a shared semantic space in which textual descriptions and visual content can be directly matched, compared, or combined. For example, models such as BLIP, Flamingo, LLaVA, and GPT-4V often use CLIP’s image encoder as the visual input component, combined with a large language model (LLM) for reasoning and generation. In other words, CLIP is responsible for converting visual signals into semantic vectors understandable by the language model—allowing the LLM to effectively “see” and comprehend images.</p>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><category term="NeuralNetwork"/><summary type="html"><![CDATA[CLIP (Contrastive Language–Image Pre-training) is a vision-language contrastive learning model proposed by OpenAI in 2021. It learns visual concepts from 400 million image–text pairs collected from the internet without any manual annotations. The model consists of an image encoder and a text encoder. Through a contrastive learning objective, it brings matching images and texts closer together in the same embedding space while pushing non-matching pairs apart, thereby obtaining general representations capable of understanding semantics across modalities.]]></summary></entry><entry><title type="html">Программа государственного экзамена по направлениям магистратуры</title><link href="https://sirenexcelsior.github.io/blog/2024/gosa/" rel="alternate" type="text/html" title="Программа государственного экзамена по направлениям магистратуры"/><published>2024-05-01T17:39:00+00:00</published><updated>2024-05-01T17:39:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/gosa</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/gosa/"><![CDATA[<p>Redirecting to pdf.</p>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><summary type="html"><![CDATA[Redirecting to pdf.]]></summary></entry><entry><title type="html">Linux Basic Command Manual</title><link href="https://sirenexcelsior.github.io/blog/2024/linux-common/" rel="alternate" type="text/html" title="Linux Basic Command Manual"/><published>2024-04-01T00:00:00+00:00</published><updated>2024-04-01T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/linux-common</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/linux-common/"><![CDATA[<h2 id="file-and-directory-operations">File and directory operations</h2> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">ls</code></strong> - <strong>List</strong>: This command lists the contents of a directory. The name “list” succinctly describes its primary function, which is to display files and directories.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="c"># list the contents of a directory</span>
<span class="nb">ls</span> <span class="nt">-l</span> <span class="c"># show detailed information</span>
<span class="nb">ls</span> <span class="nt">-a</span> <span class="c"># show hidden files</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">cd</code></strong> - <strong>Change Directory</strong>: The <code class="language-plaintext highlighter-rouge">cd</code> command is used to change the current working directory in a shell. The term “change directory” directly reflects its purpose of moving from one directory to another.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /path/to/directory <span class="c"># switch to the specified directory</span>
<span class="nb">cd</span> .. <span class="c"># to return to parent directory</span>
<span class="nb">cd</span> ./path <span class="c"># switch to the specified directory within the current directory</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">pwd</code></strong> - <strong>Print Working Directory</strong>: This command outputs the full pathname of the current working directory. “Print working directory” accurately describes the action of displaying the directory you’re currently in.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">pwd</span> <span class="c"># display the full path of the current directory</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">mkdir</code></strong> - <strong>Make Directory</strong>: The <code class="language-plaintext highlighter-rouge">mkdir</code> command creates a new directory. The name “make directory” is a straightforward indication of its function to create (or “make”) a new directory.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>new_directory <span class="c"># creating a new catalogue</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">rmdir</code></strong> - <strong>Remove Directory</strong>: This command is used to delete empty directories. The name “remove directory” clearly states that it removes directories, emphasizing that it only works on empty ones.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rmdir </span>directory_name <span class="c"># delete empty directories</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">rm</code></strong> - <strong>Remove</strong>: Unlike <code class="language-plaintext highlighter-rouge">rmdir</code>, the <code class="language-plaintext highlighter-rouge">rm</code> command is used to remove files or directories (the latter requires an option to do so recursively). The term “remove” is generic because it applies to both files and directories.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm </span>file_name <span class="c"># delete a file</span>
<span class="nb">rm</span> <span class="nt">-r</span> directory_name <span class="c"># recursive deletion of directories and their contents</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">cp</code></strong> - <strong>Copy</strong>: The <code class="language-plaintext highlighter-rouge">cp</code> command is used to copy files and directories. The term “copy” directly reflects its purpose to duplicate files or directories from one location to another.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> /source /destination <span class="c"># copy the source file to the target location</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">mv</code></strong> - <strong>Move</strong>: This command moves or renames files and directories. The name “move” is apt because it can move files or directories to a new location or simply rename them within their current directory.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mv</span> /source /destination <span class="c"># moving or renaming files or directories</span>
</code></pre></div> </div> </li> </ul>]]></content><author><name></name></author><category term="Notebooks"/><category term="Linux"/><category term="NeuralNetwork"/><summary type="html"><![CDATA[Chapter 1 of Linux Trivia]]></summary></entry><entry><title type="html">All Task of Assembly Language 2024</title><link href="https://sirenexcelsior.github.io/blog/2024/as-code/" rel="alternate" type="text/html" title="All Task of Assembly Language 2024"/><published>2024-03-30T00:00:00+00:00</published><updated>2024-03-30T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/as-code</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/as-code/"><![CDATA[<p>This is a site for the record of all test answers for the course <a href="https://scs.math.msu.ru/node/4281">Assembly Language</a>, Spring 2024, taught by Леонов Александр Георгиевич, on the online course platform <a href="https://mirera.ru/user/groups/65cb80e98cd5ad641f4efb8b">mirera.ru</a>.</p> <p>You can see some of the points about the classroom in “<a href="https://sirenexcelsior.github.io/blog/2024/as-point/">Some points about Assembly Language 2024</a>”.</p> <h2 id="lecture-01">Lecture 01</h2> <h3 id="0-example">0 (Example)</h3> <pre><code class="language-assembly">MOV AX,0	; Move 0 to register AX, i.e., assign the value
</code></pre> <h3 id="2000">2000</h3> <p>Write a program that puts 2000 in the AX register.</p> <pre><code class="language-assembly">MOV AX, 2000
</code></pre> <h3 id="data">Data</h3> <p>Write a program that puts data from BX in the AX register.</p> <pre><code class="language-assembly">MOV AX, BX
</code></pre> <h3 id="sum-example">Sum (Example)</h3> <p>Run the program that puts the sum of data from BX and CX into the AX register.</p> <pre><code class="language-assembly">MOV AX,BX
ADD AX,CX
</code></pre> <h3 id="subtract">Subtract</h3> <p>Write a program that places the result of subtracting data CX from BX into register AX.</p> <pre><code class="language-assembly">SUB BX, CX
MOV AX, BX
</code></pre> <h3 id="calculate">Calculate</h3> <p>Write a program that places the result of operation into register AX.</p> <pre><code class="language-assembly">MOV AX, 0
MOV BX, FF00
MOV CX, F
MOV DX, F1

AND CX, DX
OR  CX, 80

MOV AX, BX
OR  AX, C0
ADD AX, CX
NEG AX
</code></pre> <h3 id="swap">Swap</h3> <p>Write a program that swaps two numbers in registers BX and CX.</p> <pre><code class="language-assembly">MOV AX, BX
MOV BX, CX
MOV CX, AX
</code></pre> <h3 id="swap-return">Swap Return</h3> <p>Write a program that swaps two numbers in registers BX and CX (Not use Push/Pop or other registers)!</p> <pre><code class="language-assembly">ADD BX, CX
SUB CX, BX
NEG CX
SUB BX, CX
</code></pre> <h3 id="not">NOT</h3> <p>Bitwise Unary NOT (~) performs <em>complementation</em> or <em>negation</em> operation; inverts all the bits of the number, i.e. <em>0→1</em> and <em>1→0</em>.</p> <ul> <li> <p>Truth table:</p> <table> <thead> <tr> <th style="text-align: center"><strong>A</strong></th> <th style="text-align: center"><strong>~ A</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center">0</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">1</td> <td style="text-align: center">0</td> </tr> </tbody> </table> </li> </ul> <p>Write a program that places the result of operation NOT into register AX. (Not use Push/Pop or other registers)!</p> <pre><code class="language-assembly">NEG AX
DEC AX
</code></pre> <h3 id="remember">Remember!</h3> <p>Write a program that stores two numbers in registers BX and CX between operations.</p> <pre><code class="language-assembly">PUSH BX
PUSH CX

MOV DX,0
MOV CX,0
MOV BX,0
MOV AX,0

POP CX
POP BX
</code></pre> <h3 id="xor">XOR</h3> <p>Exclusive or or exclusive disjunction is a logical operation that is true if and only if its arguments differ (one is 1, the other is 0). Exclusive disjunction is often used for bitwise operations. Examples:</p> <ul> <li>1 XOR 1 = 0</li> <li>1 XOR 0 = 1</li> <li>0 XOR 1 = 1</li> <li>0 XOR 0 = 0</li> </ul> <p>Write a program that places the result of operation AX XOR BX into register AX. (Not use Push/Pop or all other registers, you can use only one extra register - CX)!</p> <pre><code class="language-assembly">MOV CX, AX
OR  AX, BX
AND BX, CX
NEG BX
DEC BX
AND AX, BX
</code></pre> <h3 id="left-shift-example">Left Shift (Example)</h3> <p>Run the program that multiply by 2 a number in the AX register.</p> <p><em>Do Not forget CLC before any RCL!</em></p> <pre><code class="language-assembly">CLC
RCL AX
END
</code></pre> <h3 id="right-shift">Right Shift</h3> <p>Write a program that divides by 2 the number in register CX and puts the result in register AX.</p> <p><em>Do Not forget CLC before any RCR!</em></p> <pre><code class="language-assembly">CLC
RCR CX
MOV AX, CX
</code></pre> <h3 id="multishift">MultiShift</h3> <p>Write a program that puts the value of AX multiplied by 4 into register BX and the value of AX divided by 4 into register CX.</p> <p>Use the shift operations RCL and RCR.</p> <p><em>Do Not forget CLC before any RCL and RCR!</em></p> <pre><code class="language-assembly">MOV BX, AX
MOV CX, AX

CLC
RCL BX
CLC
RCL BX

CLC
RCR CX
CLC
RCR CX
</code></pre> <h3 id="sum">Sum</h3> <p>Write a program that puts into register AX the sum of two 8-bit numbers stored in 16-bit register BX.</p> <p>Example: BX = \(032E_{16}\), result AX = \(03_{16} + 2E_{16}\) = \(31_{16}\).</p> <p>If BX=0, then AX=0.</p> <p>Use the shift operations RCL or RCR.</p> <p><em>Do Not forget CLC before any RCL and RCR!</em></p> <pre><code class="language-assembly">MOV AX, BX
AND AX, 00FF
MOV CX, BX

CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX
CLC
RCR CX

ADD AX, CX

END
</code></pre> <h2 id="lecture-02">Lecture 02</h2> <h3 id="zero-comparison-example">Zero Comparison (Example)</h3> <p>Run a program that compares BX and CX and sets AX=1 when BX = CX</p> <pre><code class="language-assembly">CMP BX,CX
JNZ ?1
MOV AX,1
?1:
</code></pre> <h3 id="comparing-two-numbers">Comparing two numbers</h3> <p>Write a program that puts 1 in register AX if BX \(\ge\) CX and 0 otherwise.</p> <pre><code class="language-assembly">CMP BX, CX
JC  ?01
MOV AX, 1
JMP ?02
?01:
MOV AX, 0
?02:
</code></pre> <h3 id="absolute-value">Absolute value</h3> <p>Write a program to put the absolute value of the difference between the numbers in BX and CX into register AX.</p> <pre><code class="language-assembly">CMP BX, CX
JNC ?01
SUB CX, BX
MOV AX, CX
JMP ?02
?01:
SUB BX, CX
MOV AX, BX
?02:
</code></pre> <h3 id="minimum">Minimum</h3> <p>Write a program that puts the minimum number of numbers from BX and CX into AX.</p> <pre><code class="language-assembly">CMP BX, CX
JC  ?01
MOV AX, CX
JMP ?02
?01:
MOV AX, BX
?02:
</code></pre> <h3 id="divisible-by-3">Divisible by 3</h3> <p>Write a program that puts 1 in register AX if BX is evenly divisible by 3, and 0 otherwise.</p> <pre><code class="language-assembly">MOV AX, BX
MOV CX, 3
JZ  ?03
?01:
SUB AX, 0
JZ  ?03
CMP AX, CX
JC  ?02
JZ  ?03
SUB AX, CX
JMP ?01

?02:
MOV AX, 0
JMP ?04

?03:
MOV AX, 1

?04:
</code></pre> <h3 id="divisible-by-2">Divisible by 2</h3> <p>Write a program that puts 1 in register AX if BX is evenly divisible by 2, and 0 otherwise.</p> <p>(Do not use all other registers, except AX and BX or any Jump command)!</p> <pre><code class="language-assembly">MOV AX, 1
AND BX, 1
SUB AX, BX
</code></pre> <h3 id="bit-number">Bit number</h3> <p>Bits in a 16-bit register are numbered from 1 (least significant bit) to 16. Write a program that finds the least significant non-zero bit number of register BX and puts the answer into register AX.</p> <p>If BX=0, then AX=0.</p> <p>Use the RCR shift operation.</p> <p>Example: BX=\(0006_{16}\) (0000 0000 0000 01102), AX=2.</p> <pre><code class="language-assembly">MOV CX, 0
MOV AX, BX

OR  AX, AX
JZ  ?01
MOV CX, 1

?02:
RCR BX
JC  ?03
INC CX
JMP ?02

?03:
MOV AX, CX
JMP ?04

?01:
MOV AX, 0

?04:
</code></pre> <h3 id="number-of-different-numbers">Number of different numbers</h3> <p>Write a program that puts in register AX the number of different numbers in BX, CX, DX.</p> <p>Example:</p> <ul> <li>DX = 0</li> <li>BX = 1</li> <li>CX = 2</li> <li>Answer AX = 3</li> </ul> <pre><code class="language-assembly">MOV AX, 3
CMP BX, CX
JNZ ?01
DEC AX

?01:
CMP BX, DX
JNZ ?02
DEC AX

?02:
CMP CX, DX
JNZ ?03
DEC AX

?03:
CMP AX, 1
JNC ?04
MOV AX, 1

?04:
</code></pre> <h3 id="number-of-maximum">Number of maximum</h3> <p>Write a program that counts the maximums in the sequence BX, CX, DX and places the result in the AX register. For example, in the sequence of numbers 1,2,3 - the maximum is unique and equals 3 (BX=1, CX=2, DX=3 ⇒ AX=1) In the sequence of numbers 3,1,3 - the maximum is 3 and there are 2 such numbers in the sequence (BX=3, CX=1, DX=3 ⇒ AX=2).</p> <pre><code class="language-assembly">MOV AX, 1
?00:
CMP BX, CX
JC  ?01
JZ  ?02
?03:
CMP BX, DX
JC  ?04
JZ  ?05
JMP ?06
?01:
MOV BX, CX
MOV AX, 1
JMP ?03
?02:
INC AX
JMP ?03
?04:
MOV BX, DX
MOV AX, 1
JMP ?06
?05:
INC AX
JMP ?06
?06:
</code></pre> <h3 id="sides-of-a-triangle">Sides of a triangle</h3> <p>Can non-negative integers in BX, CX, DX be sides of a triangle?</p> <p>The result will be AX=1 if YES and AX=0 if NOT.</p> <pre><code class="language-assembly">ADD BX, CX
MOV AX, BX
SUB BX, CX
SUB AX, DX
JZ  ?00
JC  ?00
MOV AX, 1

ADD BX, DX
MOV AX, BX
SUB BX, DX
SUB AX, CX
JZ  ?00
JC  ?00
MOV AX, 1

ADD CX, DX
MOV AX, CX
SUB CX, DX
SUB AX, BX
JZ  ?00
JC  ?00
MOV AX, 1
JMP ?03

?00:
MOV AX, 0

?03:
</code></pre> <h3 id="right-triangle">Right triangle</h3> <p>Can non-negative integers in BX, CX, DX be sides of a right triangle?</p> <p>The result will be AX=1 if yes, and AX=0 if not.</p> <p><em>Note</em>. A triangle with sides {0,0,0} is not a right triangle.</p> <pre><code class="language-assembly">PUSH DX
PUSH CX
MOV AX, BX
MOV CX, BX
DEC AX

?01:
ADD BX, CX
DEC AX
JZ  ?02
JMP ?01

?02:
POP CX
POP DX

PUSH BX
PUSH DX
MOV AX, CX
MOV BX, CX
DEC AX

?03:
ADD CX, BX
DEC AX
JZ ?04
JMP ?03

?04:
POP DX
POP BX

PUSH BX
PUSH CX
MOV AX, DX
MOV BX, DX
DEC AX

?05:
ADD DX, BX
DEC AX
JZ ?06
JMP ?05

?06:
POP CX
POP BX

MOV AX, 0

CMP BX, 0
CMP CX, 0
CMP DX, 0
JZ  ?07

ADD BX, CX
CMP BX, DX
JZ  ?09
SUB BX, CX

ADD BX, DX
CMP BX, CX
JZ  ?09
SUB BX, DX

ADD CX, DX
CMP CX, BX
JZ  ?09
SUB CX, DX
JMP ?07

?09:
MOV AX, 1
?07:
</code></pre> <h3 id="long-shift-to-the-left">Long shift to the left</h3> <p>Run a program that doubles a 32-bit number from the BX AX registers (lower part of AX).</p> <p>RCL shift operations are used.</p> <pre><code class="language-assembly">CLC
RCL AX
RCL BX
</code></pre> <h3 id="long-shift-to-the-right">Long shift to the right</h3> <p>Write a program that divides a 32-bit number from the BX AX registers (lower part of AX) by 4.</p> <p>RCR shift operations are used.</p> <pre><code class="language-assembly">RCR BX
RCR AX

RCR BX
RCR AX
</code></pre> <h3 id="adding-two-long">Adding two long</h3> <p>Write a program that adds a 32-bit long number stored in the CX, DX registers with a long number stored in the AX, BX registers.</p> <pre><code class="language-assembly">ADD BX, DX
JC  ?00
JMP ?01
?00:
INC AX
?01:
ADD AX, CX
</code></pre> <h3 id="bus-for-programmers">Bus for programmers</h3> <p>Bus tickets for programmers have a hexadecimal number. We call a ticket lucky if the sum of the two left hexadecimal digits is equal to the sum of the two right digits, for example ADE9. Example of an unsuccessful ticket: 7+8≠9+3. How many lucky ticket numbers are found from number BX to number CX, including borders?</p> <pre><code class="language-assembly">; Code to achieve the task goal: to determine whether a number is a lucky vote or not
; Method: Read four 4-bit binary numbers in sequence using 0 and 1 operations, and then use RCR to transfer the data to the real data.
; Then, judge whether the final result is 0 by adding and subtracting to determine whether it is a lucky number of votes.

SUB CX, BX          ; Subtract BX from CX, result stored in CX
ADD CX, 2           ; Add 2 to CX, adjusting the loop counter

?00: 
DEC CX              ; Decrement CX by 1
JZ ?03              ; Jump to label ?03 if CX is zero (end of loop condition)

MOV [1], BX         ; Store the value of BX into memory location addressed by 1
AND BX, 0F          ; Perform bitwise AND between BX and 0F, isolating the lowest 4 bits

MOV DX, BX          ; Move the result of AND operation into DX

MOV BX, [1]         ; Restore BX from memory location addressed by 1
AND BX, F0          ; Perform bitwise AND between BX and F0, isolating bits 4-7
CLC                 ; Clear carry flag to prepare for rotate operation
RCR BX              ; Rotate BX right through carry, shifting bits 4-7 to 0-3
RCR BX
RCR BX
RCR BX              ; Repeat rotation to complete the shift of bits 4-7 to 0-3

ADD DX, BX          ; Add the newly shifted bits in BX to DX

MOV BX, [1]         ; Restore BX from memory location addressed by 1
AND BX, F00         ; Perform bitwise AND between BX and F00, isolating bits 8-11
CLC                 ; Clear carry flag to prepare for rotate operation
RCR BX              ; Rotate BX right through carry, shifting bits 8-11 towards lower bit positions
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX              ; Repeat rotation to complete the shift of bits 8-11 to 0-3

SUB DX, BX          ; Subtract the shifted value in BX from DX

MOV BX, [1]         ; Restore BX from memory location addressed by 1
AND BX, F000        ; Perform bitwise AND between BX and F000, isolating bits 12-15
CLC                 ; Clear carry flag to prepare for rotate operation
RCR BX              ; Rotate BX right through carry, shifting bits 12-15 towards lower bit positions
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX
RCR BX              ; Repeat rotation to complete the shift of bits 12-15 to 0-3

SUB DX, BX          ; Subtract the final shifted value in BX from DX

CMP DX, 0           ; Compare DX with 0
JZ ?01              ; Jump to label ?01 if DX is zero (if comparison equals zero)
MOV BX, [1]         ; Restore BX from memory location addressed by 1
INC BX              ; Increment BX
JMP ?00             ; Jump back to start of loop at label ?00

?01: 
INC AX              ; Increment AX
MOV BX, [1]         ; Restore BX from memory location addressed by 1
INC BX              ; Increment BX
JMP ?00             ; Jump back to start of loop at label ?00

?03:                ; Label ?03, marks the end of the loop or a specific condition block
</code></pre> <div class="row mt-3"> <div class="col-12 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/AL02-15-480.webp 480w,/assets/img/AL02-15-800.webp 800w,/assets/img/AL02-15-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/AL02-15.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="lecture-03">Lecture 03</h2> <h3 id="contents-of-an-address">Contents of an Address</h3> <p>Write a program that puts the contents at address BX into register AX.</p> <pre><code class="language-assembly">MOV AX, [BX]
</code></pre> <h3 id="contents-of-2">Contents of 2</h3> <p>Write a program that gets the number plus 200 from the BX register. Place the result in the AX register.</p> <p>Example: BX=\(100_{16}\) ⇒ AX=\(300_{16}\)</p> <pre><code class="language-assembly">ADD BX, 200
MOV AX, BX
</code></pre> <h3 id="contents-of-an-address-3">Contents of an Address 3</h3> <p>Write a program that gets the number plus \(200_{16}\) located at address BX. Place the result in the AX register.</p> <pre><code class="language-assembly">ADD [BX], 200
MOV AX, [BX]
</code></pre> <h3 id="sum-of-three-numbers">Sum of three numbers</h3> <p>Write a program that puts the sum of the three numbers at addresses 0, 1, and 2 into register AX.</p> <pre><code class="language-assembly">ADD AX, [0]
ADD AX, [1]
ADD AX, [2]
</code></pre> <h3 id="amount-by-address">Amount by address</h3> <p>Write a program that substitutes into register AX the sum of three numbers located at addresses BX, BX+1, BX+2.</p> <pre><code class="language-assembly">ADD AX, [BX]
INC BX
ADD AX, [BX]
INC BX
ADD AX, [BX]
</code></pre> <h3 id="array-sum">Array Sum</h3> <p>Write a program that puts into register AX the sum of an array of length CX, starting at address BX.</p> <p>The sum of an empty array is 0.</p> <pre><code class="language-assembly">?00:
CMP CX, 0
JZ  ?01

ADD AX, [BX]
DEC CX
INC BX
JMP ?00

?01:
</code></pre> <h3 id="equal-array">Equal array</h3> <p>Write a program that puts 1 in register AX if all elements of an array of length CX are equal. The array starts at address BX. The answer is 1 if the array has length 0.</p> <pre><code class="language-assembly">MOV AX ,  1
MOV DX ,  [BX]

CMP CX ,  0
JZ  ?02
CMP CX ,  1
JZ  ?02

DEC CX
?00: 
CMP CX ,  0
JZ  ?02

INC BX
DEC CX

CMP DX ,  [BX]
JNZ ?01
JMP ?00

?01: 
MOV AX ,  0

?02: 
</code></pre> <h3 id="address-of-the-first-minimum-number">Address of the first minimum number</h3> <p>Write a program that places the address of the first minimum number in an array of length CX into register AX, starting at address BX.</p> <p>In the case of an empty sequence, the answer is 0.</p> <pre><code class="language-assembly">MOV AX, 0
CMP CX, 0
JZ  ?02

MOV AX ,  BX
MOV DX ,  [BX]

?00: 
CMP DX ,  [BX]
JC  ?01
JZ  ?01
MOV DX ,  [BX]
MOV AX ,  BX

?01: 
INC BX
DEC CX
JZ ?02
JMP ?00

?02: 
</code></pre> <h3 id="the-number-of-all-connected-increasing-subsequences">The number of all connected increasing subsequences</h3> <p>Write a program that count all connected increasing subsequences. Places the result of an array of length CX, starting at address BX nto register AX.</p> <p>In the case of an empty sequence, the answer is 0.</p> <p>Example: 1 2 3 2 3 1 ⇒ AX=3.</p> <pre><code class="language-assembly">MOV AX ,  0
CMP CX ,  0
JZ  ?02

MOV AX , 1
MOV DX ,  [BX]
INC BX

?00: 
DEC CX
CMP CX ,  0
JZ  ?02
CMP DX ,  [BX]
JZ  ?01
JNC  ?01
MOV DX ,  [BX]
INC BX
JMP ?00

?01: 
INC AX
MOV DX ,  [BX]
INC BX
JMP ?00

?02:
</code></pre> <h3 id="address-of-the-second-maximum">Address of the second maximum</h3> <p>The CX register contains a value - the number of elements of the sequence located starting from the address BX.</p> <p>In the case of an empty sequence, the answer is 0</p> <p>If there is no second maximum, the answer is 0.</p> <p>Example: 1 2 3 2 3 1 ⇒ AX=5.</p> <pre><code class="language-assembly">MOV AX ,  0
MOV [01F8] , 0			; A null address is needed for data transit in this task, and a random address is chosen here, but this is not a good method.
MOV DX ,  [BX]
ADD CX ,  2

?00: 
DEC CX
CMP CX ,  0
JZ  ?10

CMP DX ,  [BX]
JZ  ?01
JC  ?03
INC BX
JMP ?00

?01: 
INC [01F8]
CMP [01F8] ,  2
JZ  ?02
INC BX
JMP ?00


?02: 
MOV AX ,  BX
JMP ?00

?03: 
MOV DX ,  [BX]
MOV [01F8] ,  1
INC BX
JMP ?00

?10: 
</code></pre> <h3 id="number-of-local-maxima-of-the-sequence">Number of local maxima of the sequence</h3> <p>Write a program, after the execution of which, the register AX will contain the number of local maxima of the sequence.</p> <p>The CX register contains a value - the number of elements of the sequence located starting from the address BX.</p> <p>In the case of an empty sequence, the answer is 0.</p> <p>An element of a non-empty sequence is called a local maximum if it has no neighbor greater than itself. For example, a sequence of one element has one local maximum. The sequence 4, 4, 2, 3, 0 has three local maxima: the first, second, and penultimate elements.</p> <pre><code class="language-assembly">; In order to prevent the data outside the specified array will affect the data at both ends, the first judgement CX is not 0, 
; then it is a separate judgement of whether the data at both ends are satisfied, and then it is a judgement of whether the data in the middle is satisfied, 
; the trap is that if the target data of the right side of the data is greater than it, jump out of the body of the program, at this time, BX (which can be taken as a positional pointer) is still parked in the previous one, and we would like to carry out the judgemental force of the next data, so we should update the BX in time.

MOV AX , 0
CMP CX , 0
JZ  ?00

MOV DX ,  [BX]
INC BX
CMP DX ,  [BX]
JC  ?01
INC AX

?01: 
DEC BX
ADD BX ,  CX
DEC BX

MOV DX ,  [BX]
DEC BX
CMP DX ,  [BX]
JC  ?02
INC AX

?02: 

SUB CX ,  2
JZ ?00

?04: 
MOV DX ,  [BX]
INC BX
CMP DX ,  [BX]
JC  ?03
SUB BX , 2
CMP DX ,  [BX]
JC  ?05
INC AX
JMP ?05

?03: 
SUB BX,2
JMP ?05

?05:
SUB CX ,  1
JNZ ?04

?00: 
</code></pre> <h3 id="the-lengths-of-the-sides-form-a-parallelogram">The lengths of the sides form a parallelogram</h3> <p>The array contains the lengths of the sides of the parallelogram as it is traversed clockwise.</p> <p>Write a program that puts 1 in register AX if the elements of the array (lengths of sides) of size CX, starting at address BX, form a parallelogram, and zero otherwise.</p> <p>In case of error data (CX≠4) the answer is 0.</p> <pre><code class="language-assembly">MOV AX , 0
CMP CX ,  4
JNZ  ?00

MOV DX ,  [BX]
ADD BX ,  2
CMP [BX] ,  DX
JNZ ?00

ADD BX , 1
MOV DX ,  [BX]
SUB BX , 2
CMP [BX] ,  DX
JNZ ?00

MOV AX , 1

?00: 
</code></pre> <h2 id="lecture-04">Lecture 04</h2> <h3 id="the-subsequence">The subsequence</h3> <p>In memory at address 0, there is a value - the number of elements of the sequence located starting from address 1.</p> <p>Write a program that leaves the AX register the number of occurrences of the subsequence “1, 2, 3, 1”.</p> <p>In the case of an empty sequence, the answer is 0</p> <p>Example: 7 1 2 3 1 2 3 1 ⇒ AX=2.</p> <blockquote> <p>It is not emphasised here that “1, 2, 3, 1, 2, 3” should be judged as 2 subsequences.</p> </blockquote> <pre><code class="language-assembly">MOV AX ,  0
MOV BX ,  0
CMP [BX] ,  4
JC  ?00

?01: 
MOV CX ,  [0]
INC CX
CMP BX ,  CX
JZ  ?00
INC BX

CMP [BX] , 1
JZ  ?02
JMP ?01

?02: 
INC BX
CMP [BX] , 2
JZ  ?03
JMP ?01

?03: 
INC BX
CMP [BX] , 3
JZ  ?04
JMP ?01

?04: 
INC BX
CMP [BX] ,  1
JZ  ?05
JMP ?01

?05: 
INC AX
DEC BX ;The last number is 1 and the counter BX has to go backwards by one, in order to check if this 1 might be the beginning of a subsequence.
JMP ?01

?00: 
</code></pre> <h3 id="even-odd">Even-odd</h3> <p>In memory at address 0, there is a value - the number of elements of an array of natural numbers (and zero also), located starting from address 1.</p> <p>Let’s call a “strange ascent” the case when there are either even or odd numbers nearby, or the number on the left is odd and the number on the right is even.</p> <p>Write a program that sorts an array in “strange ascending” order.</p> <p>Example: 4 3 2 1 2 2 1 ⇒ 3 1 1 4 2 2 2</p> <p>Remark: Do not change order inside the equivalent class. Wrong answer: 3 1 1 2 4 2 2.</p> <blockquote> <p>The key to this task is to filter out the odd and even numbers without changing the order in which they are each arranged, and then, arrange the odd numbers first and then the even numbers. Note that the RCR approach is used when determining whether the data in memory is odd or even, but you can’t operate directly on that data because it will affect the data in the memory before and after.</p> </blockquote> <pre><code class="language-assembly">CMP [0] ,  0
JZ  ?00
MOV BX ,  0


?02: 
CMP BX ,  [0]
JZ  ?03
INC BX

CLC
MOV DX , [BX]
RCR DX
JC  ?01
JMP ?02

?01: 
PUSH [BX]
JMP ?02

?03: 
MOV BX ,  0

?04: 
CMP BX ,  [0]
JZ  ?06
INC BX

CLC
MOV DX , [BX]
RCR DX
JNC ?05
JMP ?04

?05: 
PUSH [BX]
JMP ?04

?06: 
MOV BX ,  [0]

?07: 
CMP BX ,  0
JZ  ?00
POP [BX]
DEC BX
JMP ?07
  
?00: 
</code></pre> <h3 id="adding-two-long-numbers">Adding two long numbers</h3> <p>Write a program that implements the operation of adding two very long numbers.</p> <p>Integers in the range 0 to \(2^{1024}-1\) are represented as 𝑁 ≤ 64 consecutive words of memory each.</p> <p>Register AX is the address of the first least significant word of the first number, BX=𝑁 is the length of the number.</p> <p>The numbers are in order, so the address of the first digit of the second number is AX+BX. The result must be in the first number.</p> <blockquote> <p>This task pays special attention to the progression, whether there are two numbers produced by adding them together or by the progression of the previous sum.</p> </blockquote> <pre><code class="language-assembly">MOV DX ,  0
MOV CX ,  BX

?00: 
CMP AX ,  CX
JZ  ?03
CLC
ADD [AX] , [BX]
JC  ?01
CLC
ADD [AX] ,  DX
JC  ?02
MOV DX ,  0

INC AX
INC BX
JMP ?00

?01: 
ADD [AX] ,  DX
INC AX
MOV DX , 1
INC BX
JMP ?00

?02: 
INC AX
MOV DX ,  1
INC BX
JMP ?00

?03: 
</code></pre> <h3 id="multiplying-a-number-by-2">Multiplying a number by 2</h3> <p>Write a program that implements the operation of multiplying the first of very long number number by 2.</p> <p>Integers in the range 0 to \(2^{1024}-1\) are represented as 𝑁 ≤ 64 consecutive words of memory each.</p> <p>Register AX is the address of the first least significant word of the first number, BX=𝑁 is the length of the number.</p> <p>The result must be in the first number.</p> <pre><code class="language-assembly">MOV AX ,  0
MOV DX ,  0

?00: 
CMP AX ,  BX
JZ  ?02
CLC
ADD [AX] , [AX]
JC  ?01
ADD [AX] ,  DX
MOV DX ,  0
INC AX
JMP ?00

?01: 
ADD [AX] ,  DX
INC AX
MOV DX ,  1
JMP ?00

?02: 
</code></pre> <h3 id="dividing-a-number-by-2">Dividing a number by 2</h3> <p>Write a program that implements the operation of dividing the first of very long number number by 2.</p> <p>Integers in the range 0 to \(2^{1024}-1\) are represented as 𝑁 ≤ 64 consecutive words of memory each.</p> <p>Register AX is the address of the first least significant word of the first number, BX=𝑁 is the length of the number.</p> <p>The result must be in the first number.</p> <blockquote> <p>The pitfall of this task is that it is possible to use successive RCRs to process the data in order from high to low, but it will destroy the contents of the C flag when determining whether the loop needs to end, so it needs to be specially documented.</p> </blockquote> <pre><code class="language-assembly">CLC

?00: 
RCR [BX]
JC  ?01
CMP BX ,  0
JZ  ?10
DEC BX
JMP ?00

?01: 
CMP BX ,  0
JZ  ?10
DEC BX
CMP BX ,  FFFF
JMP ?00

?10: 
</code></pre> <h2 id="lecture-05">Lecture 05</h2> <h3 id="padovan-problem-by-c">Padovan problem by C</h3> <p>A sequence of integers is read from input using the input.txt file.</p> <p>Answer (0-no, 1-yes) output to output.txt file</p> <p>In the case of an empty sequence, an empty file must be created.</p> \[a_0=1, a_1=1, a_2=1, an=a_{n-2}+a_{n-3}\] <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">recurrent</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a0</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fin</span><span class="p">,</span> <span class="o">*</span><span class="n">fout</span><span class="p">;</span>
    <span class="n">fin</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="n">fout</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"output.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">a0</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">((</span><span class="n">fin</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fscanf</span><span class="p">(</span><span class="n">fin</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fout</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">recurrent</span><span class="p">(</span><span class="n">fin</span><span class="p">,</span> <span class="n">a0</span><span class="p">));</span> 
    <span class="p">}</span>
    
    <span class="n">fclose</span><span class="p">(</span><span class="n">fin</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fout</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">recurrent</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a0</span><span class="p">)</span>
<span class="p">{</span>   
 
<span class="p">}</span>
</code></pre></div></div> <h3 id="copy-the-sequence">Copy the sequence</h3> <p>A sequence of integers in the input stream.</p> <p>For reading, the <em>inputInt</em> function is used - returning the read number in the EAX register and the Z=1 flag, in case of reading the end of the file.</p> <p>We need to copy the sequence from the input stream to the output stream.</p> <p>Functions are used for output.</p> <p><em>printiInt</em> - prints the integer contained in the EAX register,</p> <p><em>printiEndl</em> - go to another line,</p> <p>You can also use the <em>printiHex</em> function - prints the hexadecimal representation of the CL register.</p> <p>All output functions store the values of all registers except the flag registers.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex  ; Declare external functions that are used for I/O
%include 'conio.h'                             ; Include console input/output header

section .text                                  ; Begin the text (code) section of the assembly file
global _start                                  ; Declare the _start label as global so it's visible to the linker

_start:                                        ; The entry point of the program

call inputInt                                  ; Call inputInt to read an integer from standard input
mov rdi,-1                                     ; Preset rdi with -1, which is potentially used for error signaling
jz .exit                                       ; If zero flag is set (inputInt read EOF), jump to .exit
call printInt                                  ; Call printInt to print the integer in EAX
call printEndl                                 ; Call printEndl to print a newline

.repit:                                        ; Label for the beginning of the loop
call inputInt                                  ; Call inputInt to read the next integer from standard input
jz .exit0                                      ; If zero flag is set (inputInt read EOF), jump to .exit0
call printInt                                  ; Call printInt to print the integer in EAX
call printEndl                                 ; Call printEndl to print a newline
jmp .repit                                     ; Jump back to the start of the loop

.exit0:                                        ; Label for exiting after printing all integers
xor rdi, rdi                                   ; Clear rdi register (sets the value to 0) to signal successful end
.exit:                                         
mov rax, 60                                    ; Load the sys_exit system call number into rax
syscall                                        ; Make the system call to exit the program
</code></pre> <h3 id="maximum-of-the-sequence">Maximum of the sequence</h3> <p>A sequence of integers in the input stream.</p> <p>For reading, the <em>inputInt</em> function is used - returning the read number in the EAX register and the Z=1 flag, in case of reading the end of the file.</p> <p>We need to find the maximum of the sequence and print the answer to the output stream.</p> <p>Functions are used for output.</p> <p><em>printiInt</em> - prints the integer contained in the EAX register,</p> <p><em>printiEndl</em> - go to another line,</p> <p>You can also use the <em>printiHex</em> function - prints the hexadecimal representation of the CL register.</p> <p>All output functions store the values of all registers except the flag registers.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt         
    jz .emptySequence     

    mov ebx, eax          

.findMaxLoop:
    call inputInt         
    jz .printMax          

    cmp eax, ebx          
    jle .findMaxLoop      
    mov ebx, eax          
    jmp .findMaxLoop      

.printMax:
    mov eax, ebx          
    call printInt         
    call printEndl        
    jmp .exit             

.emptySequence:
    mov rax, 60
    mov edi, 255
    syscall

.exit:
    mov eax, 60           
    xor edi, edi          
    syscall               
</code></pre> <h3 id="padovan-problem">Padovan problem</h3> <p>A sequence of integers in the input stream.</p> <p>Answer (0-no, 1-yes) to the output stream, is it a Padovan sequence?</p> <p>In the case of an empty sequence, the program exit code is -1.</p> \[a_0=1, a_1=1, a_2=1, an=a_{n-2}+a_{n-3}\] <blockquote> <p>One note of caution here, rax must be assigned the value 60 on return.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt
    jz .errexit
    cmp eax, 1
    jnz .notpad
    call inputInt
    jz .ispad
    cmp eax, 1
    jnz .notpad
    call inputInt
    jz .ispad
    cmp eax, 1
    jnz .notpad
    
    
    mov ebx, 1
    mov ecx, 1
    mov edx, 1

.lp:
    call inputInt
    jz .ispad
    
    add ebx, ecx
    mov r8d, ebx
    mov ebx, ecx
    mov ecx, edx
    mov edx, r8d
    cmp eax, edx
    jnz .notpad
    jmp .lp

.ispad:
    mov eax, 1
    xor rdi, rdi
    call printInt
    jmp .exit
    
.notpad:
    mov eax, 0
    xor rdi, rdi
    call printInt
    jmp .exit
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.exit:
    mov rax, 60
    syscall
</code></pre> <h3 id="missing-number">Missing number</h3> <p>The sequence contains integers from 1 to N in arbitrary order, but one of the numbers is missing (the rest occur exactly once). N is not known in advance. Find the missing number.</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>IIn the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>Since we don’t know how many numbers there are and the order of the series, then we can only determine the number of numbers, then find the series sum if there are no missing numbers, and then subtract the actual series sum to get what the missing numbers are.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt
    jz .errexit
    
    mov ebx, 1
    mov ecx, eax
    mov edx, 1

.lp:
    call inputInt
    jz .lpend
    add ebx, 1
    add edx, ebx
    add ecx, eax
    jmp .lp

.lpend:
    add ebx, 1
    add edx, ebx
    sub edx, ecx
    mov eax, edx
    call printInt
    jmp .exit
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.exit:
    xor rdi, rdi
    mov rax, 60
    syscall
</code></pre> <h3 id="number---loner">Number - loner</h3> <p>The sequence contains integers from 1 to N. All numbers except one are written twice in random order, one of the numbers is written once. N is not known in advance. Find a number that occurs once.</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>This task involves multiplication and division, but of course you can add and subtract instead, but it’s too tedious.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt
    jz .errexit
    
    mov ebx, 1
    mov ecx, eax
    
.lp:
    call inputInt
    jz .endlp
    add ebx, 1
    add ecx, eax
    jmp .lp

.endlp:
    mov eax, ebx
    mov eax, ecx
    add ebx, 1
    mov eax, ebx
    mov ebx, 2
    div ebx
    mov ebx, eax
    add eax, 1
    mul ebx
    sub eax, ecx
    call printInt
    jmp .exit
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.exit:
    xor rdi, rdi 
    mov rax, 60
    syscall
</code></pre> <h3 id="find-the-number">Find the number</h3> <p>The sequence contains integers, more than half of which are equal to the same number X.</p> <p>It is necessary to find this number X. It is guaranteed that such a number exists.</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>This task requires the use of the “Moore’s Vote Algorithm”, the catch being that a number is read before it is judged to be empty, so the initial state of the counter is 1 and not 0.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    call inputInt
    jz .errexit
    
    mov ecx, eax
    mov edx, 1
    
.lp:
    call inputInt
    jz .exit
    cmp edx, 0
    jz .new
    cmp ecx, eax
    jz .count
    sub edx, 1
    jmp .lp
    
.new:
    mov ecx, eax
    mov edx, 1
    jmp .lp
    
.count:
    add edx, 1
    jmp .lp

.errexit:
    mov rdi, -1
    mov rax, 60
    syscall
    
.exit:
    xor rdi, rdi
    mov eax, ecx
    call printInt
    mov rax, 60
    syscall
</code></pre> <h3 id="second-highest-silver">Second highest (silver)</h3> <p>The second largest element is the one that becomes the largest element in the sequence after all elements with the highest value have been removed from it.</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>Negative numbers will appear in the program verification of the task, so the compare operation instruction should only be used with signed comparisons.</p> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:
    
    call inputInt
    jz .errexit
    mov ebx, eax
    call inputInt
    jz .emptyexit
    mov ecx, eax
    cmp ecx, ebx
    jl .lp
    mov eax, ebx
    mov ebx, ecx
    mov ecx, eax
    
.lp:
    call inputInt
    jz .ifequ
    cmp eax, ebx
    jz .lp
    jge .s1
    cmp eax, ecx
    jz .lp
    jge .s2
    jmp .lp
    
.s1:
    mov ecx, ebx
    mov ebx, eax
    jmp .lp
    
.s2:
    mov ecx, eax
    jmp .lp
    
.ifequ:
    cmp ebx, ecx
    jz .emptyexit
    jmp .exit
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.emptyexit:
    mov rdi, 0
    mov rax, 60
    syscall

.exit:
    mov rdi, 0
    mov eax, ecx
    call printInt
    mov rax, 60
    syscall
</code></pre> <h3 id="the-sum-of-pairwise-products">The sum of pairwise products</h3> <p>Find the sum of all pairwise products of a sequence</p> <p>A sequence of integers in the input stream.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>Assuming that we have only one chance to read the array and we don’t want to request dynamic memory, the problem must be solved in \(O(n)\), and that requires a formula:</p> \[SUM = \frac{1}{2}((\sum_{i=1}^na_i)^2-\sum_{i=1}^na_i^2)\] </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .text
global _start

_start:

    xor ebx, ebx
    xor ecx, ecx
    
    call inputInt
    jz .errexit
    
    add ebx, eax
    mul eax
    add ecx, eax
    
    call inputInt
    jz .errexit
    
    add ebx, eax
    mul eax
    add ecx, eax
    
.lp:
    call inputInt
    jz .endlp
    add ebx, eax
    mul eax
    add ecx, eax
    jmp .lp
    
.errexit:
    mov rdi, -1
    mov rax, 60
    syscall

.endlp:
    mov eax, ebx
    mul eax
    sub eax, ecx
    clc
    rcr eax, 1
    call printInt
    
.exit:
    mov rdi, 0
    mov rax, 60
    syscall
</code></pre> <h3 id="copy-array">Copy array</h3> <p>An array of integers is located in the file input stream. It is required to create an array of N&lt;100 elements and read the array.</p> <p>You need to copy all array to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <pre><code class="language-assembly">; External function declarations
extern printEndl, printInt, inputInt, printHex
%include 'conio.h'  ; Include the conio.h library for console input-output support

section .bss
A:resd 100  ; Allocate space for an array, defining array A to hold 100 integers

section .text
global _start  ; Declare _start as globally visible so that the linker can find the entry point of the program

_start:  ; Start of the program

mov ecx,0   ; Initialize counter ecx to 0, for array indexing
mov ebx,A   ; Assign the address of array A to ebx, for subsequent read/write operations

.readA:  ; Label for reading input
call inputInt  ; Call inputInt to read an integer from standard input into eax
jz .eofA  ; If the input is 0, jump to .eofA to handle end-of-file condition
mov [A+ecx*4],eax;  ; Store the read integer at the corresponding position in array A
inc ecx  ; Increase the value of ecx, moving to the next position in the array
jmp .readA  ; Jump back to .readA to continue reading the next integer

.eofA:  ; Handle end-of-input condition
mov rdi,-1  ; Store -1 in rdi, set as error return code
test ecx,ecx  ; Test if ecx is 0 (i.e., if the array is empty)
jz .exit  ; If the array is empty, jump directly to .exit to exit the program

mov ebx,A  ; Reset ebx to the starting address of array A
.writeA:  ; Start writing label
mov eax,[ebx]  ; Read the current element from array A into eax
call printInt  ; Call printInt to print the value of eax
call printEndl  ; Print a newline
add ebx,4  ; Move ebx to the next element in the array
loop .writeA  ; Use ecx as a counter to loop through .writeA using the loop instruction

xor rdi, rdi ; Clear rdi, set as success return code

.exit:  ; Exit label
mov rax, 60  ; Set rax to 60, corresponding to the sys_exit system call number
syscall  ; Perform a system call to exit the program
</code></pre> <h3 id="sort-array">Sort array</h3> <p>An array of integers is located in the file input stream. It is required to create an array of N&lt;100 elements and read the array.</p> <p>You need to sort an array of integers in ascending order to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <pre><code class="language-assembly">; External function declarations
extern printEndl, printInt, inputInt, printHex
%include 'conio.h'  ; Includes the conio.h library for console input-output support

section .bss
A:resd 100  ; Reserves space for an array of 100 integers

section .text
global _start  ; Declares _start as globally visible, marking the entry point of the program

_start:  ; Program start

mov ecx, 0  ; Clears the ecx register, to be used as the array index
mov ebx, A  ; Loads the address of array A into ebx for array operations
.readA:  ; Start of the loop to read the array
call inputInt  ; Calls inputInt function to read an integer from standard input
jz .eofA  ; If input is zero, jump to .eofA to handle end of input
mov [A+ecx*4], eax;  ; Stores the input integer at the current index position in the array
inc ecx  ; Increments index, preparing to read the next value
jmp .readA  ; Jumps back to the start of the read loop

.eofA:
mov rdi, -1  ; Sets return error code to -1
test ecx, ecx  ; Tests if ecx is zero, i.e., if the array is empty
jz .exit  ; If the array is empty, jumps to exit

mov ebx, A  ; Resets ebx to point to the start of the array
call _sort  ; Calls the _sort function to sort the array

mov ebx, A  ; Again sets ebx to point to the start of the array
.writeA:  ; Starts the loop to write the array
mov eax, [ebx]  ; Reads the current element from the array
call printInt  ; Calls printInt to print the current integer
call printEndl  ; Calls printEndl to print a newline
add ebx, 4  ; Moves to the next element in the array
loop .writeA  ; Continues to output using loop instruction until ecx decrements to zero

xor rdi, rdi ; Clears the rdi register, sets the success return code

.exit:
mov rax, 60  ; Sets rax to 60, corresponding to the sys_exit system call
syscall  ; Performs a system call to exit the program

_sort:
pushq  ; Saves register state
dec ecx  ; Decrement array length by one, preparing for sorting
.?loop1:  ; Label for the first loop
push rcx
push rbx

.?loop2:  ; Label for the second loop

mov eax, [ebx]  ; Takes the current element from the array
cmp eax, [ebx+4]  ; Compares it with the next element
jle .?1  ; If the current element is less than or equal to the next, skip swapping
xchg eax, [ebx+4]  ; Swaps the two elements
mov [ebx], eax

.?1:
add bx, 4  ; Moves to the next element
loop .?loop2  ; Continues the inner loop

pop rbx
pop rcx
loop .?loop1  ; Continues the outer loop
popq  ; Restores register state
ret  ; Returns to the calling point
</code></pre> <h3 id="even-strange-odd">Even strange (Odd)</h3> <p>An array of integers is located in the file input stream. It is required to create an array of N&lt;100 elements and read the array.</p> <p>You need to output:</p> <p>- the maximum even element, if the number of even elements is not less than the number of odd ones;</p> <p>- the maximum odd element, if the number of odd elements is greater than even ones.</p> <p>For example, for an array of six elements equal to 4, 6, 12, 17, 3, 8, respectively, the answer will be 12 - the largest even number, since there are more even numbers in this array.</p> <p>Answer to the output stream.</p> <p>In the case of an empty sequence, the program exit code is -1.</p> <blockquote> <p>The -2147483648 set here is the smallest negative number that can be stored in a 32-bit register, i.e. it ranges from -2147483648 to 2147483647.</p> <p>The test instruction is essentially a logical and arithmetic instruction, but it does not save the result of the operation; if the result of the operation is 0, then ZF = 1, for example:</p> <pre><code class="language-assembly">test al, 1
jz even  ; If the lowest bit of al is 0, then jump to the even tag and al is an even number

test ebx, ebx
jz is_zero  ; If ebx is 0, jump to is_zero tag
</code></pre> </blockquote> <pre><code class="language-assembly">extern printEndl, printInt, inputInt, printHex
%include 'conio.h'

section .bss
A:resd 100  ; space for an array

section .text
global _start

_start:

    mov ecx, 0      
    mov ebx, A      
    
    mov edi, -2147483648  
    mov esi, -2147483648  
    mov edx, 0            
    mov ebp, 0            

.read_loop:
    call inputInt        
    test eax, eax        
    jz .finalize          
    mov [ebx+ecx*4], eax 
    inc ecx              

    
    test eax, 1          
    jnz .odd_number 
    
.even_number:
    inc edx              
    cmp eax, esi         
    jle .skip_even        
    mov esi, eax         
    jmp .skip_odd
    
.odd_number:
    inc ebp              
    cmp eax, edi         
    jle .skip_odd        
    mov edi, eax  
    
.skip_odd:
.skip_even:
    jmp .read_loop      

.finalize:    
    test ecx, ecx
    jz .empty_array      

    
    cmp ebp, edx         
    jg .output_odd    
    
.output_even:
    mov eax, esi        
    jmp .output
    
.output_odd:
    mov eax, edi      
    
.output:
    call printInt       
    call printEndl      
    xor rdi, rdi        
    jmp .exit_program

.empty_array:
    mov rdi, -1          

.exit_program:
    mov rax, 60          
    syscall              
</code></pre>]]></content><author><name></name></author><category term="Tasks"/><category term="Math"/><category term="Code"/><summary type="html"><![CDATA[all Task of Assembly Language]]></summary></entry><entry><title type="html">Some points of Assembly Language 2024</title><link href="https://sirenexcelsior.github.io/blog/2024/as-point/" rel="alternate" type="text/html" title="Some points of Assembly Language 2024"/><published>2024-03-30T00:00:00+00:00</published><updated>2024-03-30T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/as-point</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/as-point/"><![CDATA[<p>This is a site for some points about the course <a href="https://scs.math.msu.ru/node/4281">Assembly Language</a>, Spring 2024, taught by Леонов Александр Георгиевич, on the online course platform <a href="https://mirera.ru/user/groups/65cb80e98cd5ad641f4efb8b">mirera.ru</a>.</p> <h2 id="16-bit-computing">16-bit computing</h2> <h3 id="true-form-ones-complement-and-twos-complement">True Form, Ones’ Complement and Two’s Complement</h3> <h4 id="true-form">True Form</h4> <p>Sign-magnitude is the most intuitive representation method. In sign-magnitude, the most significant bit (often called the sign bit) is used to represent the sign of the number, where <code class="language-plaintext highlighter-rouge">0</code> denotes a positive value and <code class="language-plaintext highlighter-rouge">1</code> denotes a negative value. The remaining bits represent the magnitude of the number.</p> <p>For example, if we represent a decimal number using 8-bit binary:</p> <ul> <li><code class="language-plaintext highlighter-rouge">+9</code> in sign-magnitude is <code class="language-plaintext highlighter-rouge">00001001</code> (the first bit is the sign bit, <code class="language-plaintext highlighter-rouge">0</code> for positive, followed by the 7-bit binary representation of the number 9).</li> <li><code class="language-plaintext highlighter-rouge">-9</code> in sign-magnitude is <code class="language-plaintext highlighter-rouge">10001001</code> (the first bit is the sign bit, <code class="language-plaintext highlighter-rouge">1</code> for negative, the next 7 bits still represent the number 9).</li> </ul> <p>The range of integers that can be represented:</p> <ul> <li>The range for positive numbers: <code class="language-plaintext highlighter-rouge">00000001</code> to <code class="language-plaintext highlighter-rouge">01111111</code>, which corresponds to decimal <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">127</code>.</li> <li>The range for negative numbers: <code class="language-plaintext highlighter-rouge">10000001</code> to <code class="language-plaintext highlighter-rouge">11111111</code>, which corresponds to decimal <code class="language-plaintext highlighter-rouge">-1</code> to <code class="language-plaintext highlighter-rouge">-127</code>.</li> <li>Positive zero: <code class="language-plaintext highlighter-rouge">00000000</code>, which corresponds to decimal <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>Negative zero: <code class="language-plaintext highlighter-rouge">10000000</code>, which is considered as <code class="language-plaintext highlighter-rouge">-0</code> in sign-magnitude representation, but in reality, <code class="language-plaintext highlighter-rouge">-0</code> is equivalent to <code class="language-plaintext highlighter-rouge">+0</code> in value.</li> </ul> <p>Thus, using sign-magnitude, an 8-bit register can represent integers in the range of <code class="language-plaintext highlighter-rouge">-127</code> to <code class="language-plaintext highlighter-rouge">+127</code>, plus a <code class="language-plaintext highlighter-rouge">0</code>.</p> <h4 id="ones-complement">Ones’ Complement</h4> <p>Ones’ complement is used for representing negative numbers. For positive numbers, the ones’ complement is the same as the sign-magnitude; for negative numbers, the ones’ complement is obtained by inverting all the bits of the magnitude part of the number.</p> <p>Continuing with the same examples:</p> <ul> <li><code class="language-plaintext highlighter-rouge">+9</code> in ones’ complement remains the same as its sign-magnitude, which is <code class="language-plaintext highlighter-rouge">00001001</code>.</li> <li><code class="language-plaintext highlighter-rouge">-9</code> in ones’ complement is <code class="language-plaintext highlighter-rouge">11110110</code> (the sign bit remains <code class="language-plaintext highlighter-rouge">1</code>, while the rest of the bits are inverted).</li> </ul> <p>The range of integers that can be represented:</p> <ul> <li>The range for positive numbers: Same as sign-magnitude, from <code class="language-plaintext highlighter-rouge">00000001</code> to <code class="language-plaintext highlighter-rouge">01111111</code>, decimal <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">127</code>.</li> <li>The range for negative numbers: <code class="language-plaintext highlighter-rouge">11111110</code> to <code class="language-plaintext highlighter-rouge">10000000</code>, decimal <code class="language-plaintext highlighter-rouge">-1</code> to <code class="language-plaintext highlighter-rouge">-127</code> (note that negative numbers are the inversion of their magnitude).</li> <li>Positive zero: <code class="language-plaintext highlighter-rouge">00000000</code>, decimal <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>Negative zero: <code class="language-plaintext highlighter-rouge">11111111</code>, which is the representation of <code class="language-plaintext highlighter-rouge">-0</code> in ones’ complement.</li> </ul> <p>The integer range for ones’ complement representation is also <code class="language-plaintext highlighter-rouge">-127</code> to <code class="language-plaintext highlighter-rouge">+127</code>, but there are two representations for zero.</p> <h4 id="twos-complement">Two’s Complement</h4> <p>Two’s complement is also used to represent negative numbers and is the standard in modern computer systems. For positive numbers, the two’s complement is the same as the sign-magnitude; for negative numbers, the two’s complement is found by adding one to the ones’ complement of the number’s magnitude.</p> <p>Continuing with the same examples:</p> <ul> <li><code class="language-plaintext highlighter-rouge">+9</code> in two’s complement is the same as its sign-magnitude, <code class="language-plaintext highlighter-rouge">00001001</code>.</li> <li><code class="language-plaintext highlighter-rouge">-9</code> in two’s complement is the ones’ complement <code class="language-plaintext highlighter-rouge">11110110</code> plus one, resulting in <code class="language-plaintext highlighter-rouge">11110111</code>.</li> </ul> <p>The range of integers that can be represented:</p> <ul> <li>The range for positive numbers: Same as sign-magnitude and ones’ complement, from <code class="language-plaintext highlighter-rouge">00000001</code> to <code class="language-plaintext highlighter-rouge">01111111</code>, decimal <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">127</code>.</li> <li>The range for negative numbers: <code class="language-plaintext highlighter-rouge">11111111</code> to <code class="language-plaintext highlighter-rouge">10000000</code>, decimal <code class="language-plaintext highlighter-rouge">-1</code> to <code class="language-plaintext highlighter-rouge">-128</code>. Note that in two’s complement, <code class="language-plaintext highlighter-rouge">10000000</code> represents <code class="language-plaintext highlighter-rouge">-128</code>.</li> <li>Zero: <code class="language-plaintext highlighter-rouge">00000000</code>, in two’s complement, there is only one representation of zero, decimal <code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <h3 id="common-arithmetic-instructions">Common Arithmetic Instructions</h3> <table> <thead> <tr> <th>Command</th> <th>Action</th> <th>Example</th> <th>Flag Z</th> <th>Flag C</th> </tr> </thead> <tbody> <tr> <td>DEC d</td> <td>d = d-1</td> <td>DEC AX</td> <td>✓</td> <td>-</td> </tr> <tr> <td>INC d</td> <td>d = d+1</td> <td>INC [BX]</td> <td>✓</td> <td>-</td> </tr> <tr> <td>ADD d,s</td> <td>d = d+s</td> <td>ADD AX, 20</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>SUB d,s</td> <td>d = d-s</td> <td>SUB CX, [1]</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>MOV d,s</td> <td>d = s</td> <td>MOV AX, [100]</td> <td>-</td> <td>-</td> </tr> <tr> <td>ADC d,s</td> <td>d = d+s+C</td> <td>ADC [AX], 20</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>SBB d,s</td> <td>d = d-s-C</td> <td>SBB [02], 1</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>CMP d,s</td> <td>d - s</td> <td>CMP AX, [1]</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>POP d</td> <td>d = [SP–]</td> <td>POP BX</td> <td>-</td> <td>-</td> </tr> <tr> <td>PUSH d</td> <td>[++SP] = d</td> <td>PUSH [102]</td> <td>-</td> <td>-</td> </tr> <tr> <td>AND d,s</td> <td>d = d &amp; s</td> <td>AND AX, [1]</td> <td>✓</td> <td>0</td> </tr> <tr> <td>OR d,s</td> <td>d = d | s</td> <td>OR [BX], [AX]</td> <td>✓</td> <td>0</td> </tr> <tr> <td>NEG d</td> <td>d = -d</td> <td>NEG [AX]</td> <td>✓</td> <td>✓</td> </tr> <tr> <td>RCL d</td> <td>C -&gt; \(d_0\),d = d*2,\(d_{15}\) -&gt; C</td> <td>RCL BX</td> <td>-</td> <td>✓</td> </tr> <tr> <td>RCR d</td> <td>C -&gt; \(d_{15}\),d=d/2,\(d_0\)-&gt; C</td> <td>RCR [2]</td> <td>-</td> <td>✓</td> </tr> </tbody> </table> <h4 id="adc-add-with-carry">ADC (Add with Carry)</h4> <p>The <code class="language-plaintext highlighter-rouge">ADC</code> instruction stands for “Add with Carry.” It adds the source operand (s), the destination operand (d), and the carry flag (C) together.</p> <p><strong>Use cases</strong>:</p> <ul> <li><strong>Multi-byte addition</strong>: <code class="language-plaintext highlighter-rouge">ADC</code> is used when performing addition operations that exceed the capacity of a single register. For instance, in a 32-bit system, if we need to add two 64-bit numbers, we would need to divide this operation into two parts, each 32 bits, held in two separate registers. First, we add the lower 32 bits, and then use <code class="language-plaintext highlighter-rouge">ADC</code> to add the upper 32 bits, which automatically includes the carry from the lower addition if there is one.</li> <li><strong>Extended arithmetic operations</strong>: During extended arithmetic operations, such as those found in cryptography or digital signature algorithms, operands can be very large and not fit within a single register. <code class="language-plaintext highlighter-rouge">ADC</code> is useful here to handle each segment of the operand and include carryovers from previous additions.</li> </ul> <h4 id="sbb-subtract-with-borrow">SBB (Subtract with Borrow)</h4> <p>The <code class="language-plaintext highlighter-rouge">SBB</code> instruction stands for “Subtract with Borrow.” It subtracts the source operand (s) from the destination operand (d) and then also subtracts the carry flag (C), which in the context of subtraction is treated as a borrow.</p> <p><strong>Use cases</strong>:</p> <ul> <li><strong>Multi-byte subtraction</strong>: Similar to <code class="language-plaintext highlighter-rouge">ADC</code>, <code class="language-plaintext highlighter-rouge">SBB</code> is used for subtraction that involves numbers larger than what a single register can hold. After subtracting the lower part of the operands, <code class="language-plaintext highlighter-rouge">SBB</code> helps to subtract the higher part along with any borrow that resulted from the lower subtraction.</li> <li><strong>Extended arithmetic operations</strong>: For large numerical operations that require precise subtraction over multiple data words, <code class="language-plaintext highlighter-rouge">SBB</code> can sequentially subtract along with borrows, ensuring that the extended precision is maintained across the entire operation.</li> </ul> <h4 id="large-number-addition-and-large-number-subtraction">Large Number Addition and Large Number Subtraction</h4> <p>To perform large number arithmetic with numbers stored across two registers, you would perform addition or subtraction by handling the carry or borrow flags appropriately.</p> <pre><code class="language-assembly">; Assuming AX:BX contains the first large number (higher part in AX, lower part in BX)
; Assuming CX:DX contains the second large number (higher part in CX, lower part in DX)
; The result will be stored in AX:BX

; First, add the lower parts
ADD BX, DX ; BX = lower part of the first number + lower part of the second number
ADC AX, CX ; AX = higher part of the first number + higher part of the second number + carry

; Assuming AX:BX contains the first large number (higher part in AX, lower part in BX)
; Assuming CX:DX contains the second large number (higher part in CX, lower part in DX)
; The result will be stored in AX:BX

; First, subtract the lower parts
SUB BX, DX ; BX = lower part of the first number - lower part of the second number
SBB AX, CX ; AX = higher part of the first number - higher part of the second number - borrow
</code></pre>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><category term="Code"/><summary type="html"><![CDATA[some points of Assembly Language]]></summary></entry><entry><title type="html">Философия математики</title><link href="https://sirenexcelsior.github.io/blog/2024/math-philosophy/" rel="alternate" type="text/html" title="Философия математики"/><published>2024-03-01T00:00:00+00:00</published><updated>2024-03-01T00:00:00+00:00</updated><id>https://sirenexcelsior.github.io/blog/2024/math-philosophy</id><content type="html" xml:base="https://sirenexcelsior.github.io/blog/2024/math-philosophy/"><![CDATA[<h2 id="книжный-список">Книжный список</h2> <table> <thead> <tr> <th>Название книги</th> <th style="text-align: center">Автор</th> <th style="text-align: center">Главы и номера страниц</th> <th style="text-align: center"> </th> </tr> </thead> <tbody> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Давид%20Гильберь.%20О%20бесконечном.%20Гильберт%20избранные%20труды%20том%201.pdf">Гильберт избранные труды том 1. 1930</a></td> <td style="text-align: center">Давид Гильберь</td> <td style="text-align: center">О бесконечном. Начало на стр. 431</td> <td style="text-align: center"> </td> </tr> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Николя%20Бурбаки.%20Архитектура%20математики.pdf">Архитектура математики</a></td> <td style="text-align: center">Николя Бурбаки</td> <td style="text-align: center">-</td> <td style="text-align: center"> </td> </tr> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Г.%20Кантор%2C%20книга%20%22Теория%20множеств%22%2C%201985%2C%20Москва.pdf">Труды по теории множеств, 1985, Москва</a></td> <td style="text-align: center">Георг Кантор</td> <td style="text-align: center">Стр 63-81 статья “Основа общего учения о многообразиях “</td> <td style="text-align: center"> </td> </tr> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Анри%20Пуанкаре%2C%20книга%20в%204х%20томах%20О%20науке.pdf">Книга в 4х томах “О науке”</a></td> <td style="text-align: center">Анри Пуанкаре</td> <td style="text-align: center">параграф “Интуиция и логика в математике”. Начало на стр. 159</td> <td style="text-align: center"> </td> </tr> <tr> <td><a href="https://sirenexcelsior.github.io/assets/pdf/master_phi/Nepostizhimaya_effektivnost_matematiki_v_estestvennykh_naukakh_E_Vigner.pdf">Непостижимая эффективность математики в естественных науках</a></td> <td style="text-align: center">Юджин Вигнер</td> <td style="text-align: center">-/<a href="https://vk.com/@-91031095-nepostizhimaya-effektivnost-matematiki-v-estestvennyh-naukah">Website</a></td> <td style="text-align: center"> </td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Notebooks"/><category term="Math"/><category term="Philosophy"/><summary type="html"><![CDATA[Книжный список]]></summary></entry></feed>